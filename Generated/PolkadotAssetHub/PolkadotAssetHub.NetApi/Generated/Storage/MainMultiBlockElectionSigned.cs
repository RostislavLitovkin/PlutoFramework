//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace PolkadotAssetHub.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> MultiBlockElectionSignedStorage
    /// </summary>
    public sealed class MultiBlockElectionSignedStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> MultiBlockElectionSignedStorage Constructor
        /// </summary>
        public MultiBlockElectionSignedStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionSigned", "Invulnerables"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT60)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionSigned", "SortedScores"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT63)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionSigned", "SubmissionStorage"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.asset_hub_polkadot_runtime.staking.NposCompactSolution16)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionSigned", "SubmissionMetadataStorage"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.signed.SubmissionMetadata)));
        }
        
        /// <summary>
        /// >> InvulnerablesParams
        ///  Accounts whitelisted by governance to always submit their solutions.
        /// 
        ///  They are different in that:
        /// 
        ///  * They always pay a fixed deposit for submission, specified by
        ///    [`Config::InvulnerableDeposit`]. They pay no page deposit.
        ///  * If _ejected_ by better solution from [`SortedScores`], they will get their full deposit
        ///    back.
        ///  * They always get their tx-fee back even if they are _discarded_.
        /// </summary>
        public static string InvulnerablesParams()
        {
            return RequestGenerator.GetStorage("MultiBlockElectionSigned", "Invulnerables", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> InvulnerablesDefault
        /// Default value as hex string
        /// </summary>
        public static string InvulnerablesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Accounts whitelisted by governance to always submit their solutions.
        /// 
        ///  They are different in that:
        /// 
        ///  * They always pay a fixed deposit for submission, specified by
        ///    [`Config::InvulnerableDeposit`]. They pay no page deposit.
        ///  * If _ejected_ by better solution from [`SortedScores`], they will get their full deposit
        ///    back.
        ///  * They always get their tx-fee back even if they are _discarded_.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT60> Invulnerables(string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionSignedStorage.InvulnerablesParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT60>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SortedScoresParams
        /// </summary>
        public static string SortedScoresParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionSigned", "SortedScores", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SortedScoresDefault
        /// Default value as hex string
        /// </summary>
        public static string SortedScoresDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SortedScores
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT63> SortedScores(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionSignedStorage.SortedScoresParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT63>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SubmissionStorageParams
        ///  Triple map from (round, account, page) to a solution page.
        /// </summary>
        public static string SubmissionStorageParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionSigned", "SubmissionStorage", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> SubmissionStorageDefault
        /// Default value as hex string
        /// </summary>
        public static string SubmissionStorageDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SubmissionStorage
        ///  Triple map from (round, account, page) to a solution page.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.asset_hub_polkadot_runtime.staking.NposCompactSolution16> SubmissionStorage(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionSignedStorage.SubmissionStorageParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.asset_hub_polkadot_runtime.staking.NposCompactSolution16>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SubmissionMetadataStorageParams
        ///  Map from account to the metadata of their submission.
        /// 
        ///  invariant: for any Key1 of type `AccountId` in [`Submissions`], this storage map also has a
        ///  value.
        /// </summary>
        public static string SubmissionMetadataStorageParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionSigned", "SubmissionMetadataStorage", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> SubmissionMetadataStorageDefault
        /// Default value as hex string
        /// </summary>
        public static string SubmissionMetadataStorageDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SubmissionMetadataStorage
        ///  Map from account to the metadata of their submission.
        /// 
        ///  invariant: for any Key1 of type `AccountId` in [`Submissions`], this storage map also has a
        ///  value.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.signed.SubmissionMetadata> SubmissionMetadataStorage(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionSignedStorage.SubmissionMetadataStorageParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.signed.SubmissionMetadata>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> MultiBlockElectionSignedCalls
    /// </summary>
    public sealed class MultiBlockElectionSignedCalls
    {
        
        /// <summary>
        /// >> register
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Register(PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore claimed_score)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(claimed_score.Encode());
            return new Method(88, "MultiBlockElectionSigned", 0, "register", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> submit_page
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SubmitPage(Substrate.NetApi.Model.Types.Primitive.U32 page, Substrate.NetApi.Model.Types.Base.BaseOpt<PolkadotAssetHub.NetApi.Generated.Model.asset_hub_polkadot_runtime.staking.NposCompactSolution16> maybe_solution)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(page.Encode());
            byteArray.AddRange(maybe_solution.Encode());
            return new Method(88, "MultiBlockElectionSigned", 1, "submit_page", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bail
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Bail()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(88, "MultiBlockElectionSigned", 2, "bail", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_old_round_data
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClearOldRoundData(Substrate.NetApi.Model.Types.Primitive.U32 round, Substrate.NetApi.Model.Types.Primitive.U32 witness_pages)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(round.Encode());
            byteArray.AddRange(witness_pages.Encode());
            return new Method(88, "MultiBlockElectionSigned", 3, "clear_old_round_data", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_invulnerables
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetInvulnerables(Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> inv)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(inv.Encode());
            return new Method(88, "MultiBlockElectionSigned", 4, "set_invulnerables", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> MultiBlockElectionSignedConstants
    /// </summary>
    public sealed class MultiBlockElectionSignedConstants
    {
    }
    
    /// <summary>
    /// >> MultiBlockElectionSignedErrors
    /// </summary>
    public enum MultiBlockElectionSignedErrors
    {
        
        /// <summary>
        /// >> PhaseNotSigned
        /// The phase is not signed.
        /// </summary>
        PhaseNotSigned,
        
        /// <summary>
        /// >> Duplicate
        /// The submission is a duplicate.
        /// </summary>
        Duplicate,
        
        /// <summary>
        /// >> QueueFull
        /// The queue is full.
        /// </summary>
        QueueFull,
        
        /// <summary>
        /// >> BadPageIndex
        /// The page index is out of bounds.
        /// </summary>
        BadPageIndex,
        
        /// <summary>
        /// >> NotRegistered
        /// The account is not registered.
        /// </summary>
        NotRegistered,
        
        /// <summary>
        /// >> NoSubmission
        /// No submission found.
        /// </summary>
        NoSubmission,
        
        /// <summary>
        /// >> RoundNotOver
        /// Round is not yet over.
        /// </summary>
        RoundNotOver,
        
        /// <summary>
        /// >> BadWitnessData
        /// Bad witness data provided.
        /// </summary>
        BadWitnessData,
        
        /// <summary>
        /// >> TooManyInvulnerables
        /// Too many invulnerable accounts are provided,
        /// </summary>
        TooManyInvulnerables,
    }
}
