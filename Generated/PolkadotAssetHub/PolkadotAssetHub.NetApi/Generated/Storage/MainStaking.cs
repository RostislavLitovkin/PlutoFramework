//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace PolkadotAssetHub.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> StakingStorage
    /// </summary>
    public sealed class StakingStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> StakingStorage Constructor
        /// </summary>
        public StakingStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Invulnerables"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT39)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Bonded"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinNominatorBond"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinValidatorBond"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinimumActiveStake"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinCommission"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Ledger"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ledger.StakingLedger)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Payee"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Validators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForValidators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxValidatorsCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Nominators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.Nominations)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForNominators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "VirtualStakers"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForVirtualStakers"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxNominatorsCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ActiveEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ActiveEraInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "BondedEras"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT65)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersOverview"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_staking.PagedExposureMetadata)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersPaged"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.BoundedExposurePage)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ClaimedRewards"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.weak_bounded_vec.WeakBoundedVecT3)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorPrefs"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorReward"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasRewardPoints"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EraRewardPoints)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasTotalStake"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ForceEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumForcing)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxStakedRewards"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashRewardFraction"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CanceledSlashPayout"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "OffenceQueue"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.slashing.OffenceRecord)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "OffenceQueueEras"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.weak_bounded_vec.WeakBoundedVecT4)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ProcessingOffence"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.slashing.OffenceRecord>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "UnappliedSlashes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U32>>), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.UnappliedSlash)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CancelledSlashes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT66)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorSlashInEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ChillThreshold"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "VoterSnapshotStatus"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumSnapshotStatus)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "NextElectionPage"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ElectableStashes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_btree_set.BoundedBTreeSetT3)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "EraPruningState"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumPruningStep)));
        }
        
        /// <summary>
        /// >> ValidatorCountParams
        ///  The ideal number of active validators.
        /// </summary>
        public static string ValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ValidatorCountDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorCountDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of active validators.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> ValidatorCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> InvulnerablesParams
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public static string InvulnerablesParams()
        {
            return RequestGenerator.GetStorage("Staking", "Invulnerables", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> InvulnerablesDefault
        /// Default value as hex string
        /// </summary>
        public static string InvulnerablesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT39> Invulnerables(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.InvulnerablesParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT39>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BondedParams
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string BondedParams(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Bonded", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> BondedDefault
        /// Default value as hex string
        /// </summary>
        public static string BondedDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> Bonded(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.BondedParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinNominatorBondParams
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public static string MinNominatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinNominatorBond", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinNominatorBondDefault
        /// Default value as hex string
        /// </summary>
        public static string MinNominatorBondDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinNominatorBond(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinNominatorBondParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinValidatorBondParams
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public static string MinValidatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinValidatorBond", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinValidatorBondDefault
        /// Default value as hex string
        /// </summary>
        public static string MinValidatorBondDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinValidatorBond(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinValidatorBondParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinimumActiveStakeParams
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        public static string MinimumActiveStakeParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinimumActiveStake", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumActiveStakeDefault
        /// Default value as hex string
        /// </summary>
        public static string MinimumActiveStakeDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinimumActiveStake
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinimumActiveStake(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinimumActiveStakeParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinCommissionParams
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public static string MinCommissionParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinCommission", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinCommissionDefault
        /// Default value as hex string
        /// </summary>
        public static string MinCommissionDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill> MinCommission(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinCommissionParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LedgerParams
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// 
        ///  Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        ///  by [`StakingLedger`] to ensure data and lock consistency.
        /// </summary>
        public static string LedgerParams(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Ledger", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> LedgerDefault
        /// Default value as hex string
        /// </summary>
        public static string LedgerDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// 
        ///  Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        ///  by [`StakingLedger`] to ensure data and lock consistency.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ledger.StakingLedger> Ledger(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.LedgerParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ledger.StakingLedger>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PayeeParams
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string PayeeParams(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Payee", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PayeeDefault
        /// Default value as hex string
        /// </summary>
        public static string PayeeDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination> Payee(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.PayeeParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ValidatorsParams
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string ValidatorsParams(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Validators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorsDefault()
        {
            return "0x0000";
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs> Validators(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForValidatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForValidators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForValidatorsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForValidators(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CounterForValidatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaxValidatorsCountParams
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxValidatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxValidatorsCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxValidatorsCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxValidatorsCountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaxValidatorsCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MaxValidatorsCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NominatorsParams
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string NominatorsParams(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Nominators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> NominatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string NominatorsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.Nominations> Nominators(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.Nominations>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForNominatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForNominatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForNominators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForNominatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForNominatorsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForNominators(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CounterForNominatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> VirtualStakersParams
        ///  Stakers whose funds are managed by other pallets.
        /// 
        ///  This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        ///  are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        ///  directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        ///  via low level apis. We keep track of them to do minimal integrity checks.
        /// </summary>
        public static string VirtualStakersParams(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "VirtualStakers", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> VirtualStakersDefault
        /// Default value as hex string
        /// </summary>
        public static string VirtualStakersDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> VirtualStakers
        ///  Stakers whose funds are managed by other pallets.
        /// 
        ///  This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        ///  are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        ///  directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        ///  via low level apis. We keep track of them to do minimal integrity checks.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple> VirtualStakers(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.VirtualStakersParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForVirtualStakersParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForVirtualStakersParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForVirtualStakers", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForVirtualStakersDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForVirtualStakersDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForVirtualStakers
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForVirtualStakers(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CounterForVirtualStakersParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaxNominatorsCountParams
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxNominatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxNominatorsCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxNominatorsCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxNominatorsCountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaxNominatorsCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MaxNominatorsCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CurrentEraParams
        ///  The current planned era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public static string CurrentEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentEraDefault
        /// Default value as hex string
        /// </summary>
        public static string CurrentEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current planned era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CurrentEra(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CurrentEraParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ActiveEraParams
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to what is RC's session pallet.
        /// </summary>
        public static string ActiveEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ActiveEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ActiveEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ActiveEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to what is RC's session pallet.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ActiveEraInfo> ActiveEra(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ActiveEraParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ActiveEraInfo>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BondedErasParams
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public static string BondedErasParams()
        {
            return RequestGenerator.GetStorage("Staking", "BondedEras", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> BondedErasDefault
        /// Default value as hex string
        /// </summary>
        public static string BondedErasDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT65> BondedEras(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.BondedErasParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT65>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStakersOverviewParams
        ///  Summary of validator exposure at a given era.
        /// 
        ///  This contains the total stake in support of the validator and their own stake. In addition,
        ///  it can also be used to get the number of nominators backing this validator and the number of
        ///  exposure pages they are divided into. The page count is useful to determine the number of
        ///  pages of rewards that needs to be claimed.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///  Should only be accessed through `Eras`.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty overview is returned.
        /// </summary>
        public static string ErasStakersOverviewParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersOverview", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersOverviewDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersOverviewDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasStakersOverview
        ///  Summary of validator exposure at a given era.
        /// 
        ///  This contains the total stake in support of the validator and their own stake. In addition,
        ///  it can also be used to get the number of nominators backing this validator and the number of
        ///  exposure pages they are divided into. The page count is useful to determine the number of
        ///  pages of rewards that needs to be claimed.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///  Should only be accessed through `Eras`.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty overview is returned.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_staking.PagedExposureMetadata> ErasStakersOverview(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersOverviewParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_staking.PagedExposureMetadata>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStakersPagedParams
        ///  Paginated exposure of a validator at given era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion, then stash account and finally
        ///  the page. Should only be accessed through `Eras`.
        /// 
        ///  This is cleared after [`Config::HistoryDepth`] eras.
        /// </summary>
        public static string ErasStakersPagedParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersPaged", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersPagedDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersPagedDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasStakersPaged
        ///  Paginated exposure of a validator at given era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion, then stash account and finally
        ///  the page. Should only be accessed through `Eras`.
        /// 
        ///  This is cleared after [`Config::HistoryDepth`] eras.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.BoundedExposurePage> ErasStakersPaged(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersPagedParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.BoundedExposurePage>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ClaimedRewardsParams
        ///  History of claimed paged rewards by era and validator.
        /// 
        ///  This is keyed by era and validator stash which maps to the set of page indexes which have
        ///  been claimed.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public static string ClaimedRewardsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ClaimedRewards", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ClaimedRewardsDefault
        /// Default value as hex string
        /// </summary>
        public static string ClaimedRewardsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ClaimedRewards
        ///  History of claimed paged rewards by era and validator.
        /// 
        ///  This is keyed by era and validator stash which maps to the set of page indexes which have
        ///  been claimed.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.weak_bounded_vec.WeakBoundedVecT3> ClaimedRewards(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ClaimedRewardsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.weak_bounded_vec.WeakBoundedVecT3>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasValidatorPrefsParams
        ///  Exposure of validator at era with the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public static string ErasValidatorPrefsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorPrefs", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefsDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasValidatorPrefsDefault()
        {
            return "0x0000";
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Exposure of validator at era with the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs> ErasValidatorPrefs(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorPrefsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasValidatorRewardParams
        ///  The total validator era payout for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public static string ErasValidatorRewardParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorReward", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasValidatorRewardDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasValidatorRewardDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> ErasValidatorReward(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorRewardParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasRewardPointsParams
        ///  Rewards for the last [`Config::HistoryDepth`] eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public static string ErasRewardPointsParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasRewardPoints", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasRewardPointsDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasRewardPointsDefault()
        {
            return "0x0000000000";
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last [`Config::HistoryDepth`] eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EraRewardPoints> ErasRewardPoints(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasRewardPointsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EraRewardPoints>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasTotalStakeParams
        ///  The total amount staked for the last [`Config::HistoryDepth`] eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public static string ErasTotalStakeParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasTotalStake", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasTotalStakeDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasTotalStakeDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last [`Config::HistoryDepth`] eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> ErasTotalStake(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasTotalStakeParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ForceEraParams
        ///  Mode of era forcing.
        /// </summary>
        public static string ForceEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ForceEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ForceEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ForceEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumForcing> ForceEra(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ForceEraParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumForcing>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaxStakedRewardsParams
        ///  Maximum staked rewards, i.e. the percentage of the era inflation that
        ///  is used for stake rewards.
        ///  See [Era payout](./index.html#era-payout).
        /// </summary>
        public static string MaxStakedRewardsParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxStakedRewards", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxStakedRewardsDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxStakedRewardsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaxStakedRewards
        ///  Maximum staked rewards, i.e. the percentage of the era inflation that
        ///  is used for stake rewards.
        ///  See [Era payout](./index.html#era-payout).
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent> MaxStakedRewards(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MaxStakedRewardsParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SlashRewardFractionParams
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public static string SlashRewardFractionParams()
        {
            return RequestGenerator.GetStorage("Staking", "SlashRewardFraction", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> SlashRewardFractionDefault
        /// Default value as hex string
        /// </summary>
        public static string SlashRewardFractionDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill> SlashRewardFraction(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.SlashRewardFractionParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CanceledSlashPayoutParams
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public static string CanceledSlashPayoutParams()
        {
            return RequestGenerator.GetStorage("Staking", "CanceledSlashPayout", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CanceledSlashPayoutDefault
        /// Default value as hex string
        /// </summary>
        public static string CanceledSlashPayoutDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> CanceledSlashPayout(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CanceledSlashPayoutParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OffenceQueueParams
        ///  Stores reported offences in a queue until they are processed in subsequent blocks.
        /// 
        ///  Each offence is recorded under the corresponding era index and the offending validator's
        ///  account. If an offence spans multiple pages, only one page is processed at a time. Offences
        ///  are handled sequentially, with their associated slashes computed and stored in
        ///  `UnappliedSlashes`. These slashes are then applied in a future era as determined by
        ///  `SlashDeferDuration`.
        /// 
        ///  Any offences tied to an era older than `BondingDuration` are automatically dropped.
        ///  Processing always prioritizes the oldest era first.
        /// </summary>
        public static string OffenceQueueParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "OffenceQueue", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> OffenceQueueDefault
        /// Default value as hex string
        /// </summary>
        public static string OffenceQueueDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> OffenceQueue
        ///  Stores reported offences in a queue until they are processed in subsequent blocks.
        /// 
        ///  Each offence is recorded under the corresponding era index and the offending validator's
        ///  account. If an offence spans multiple pages, only one page is processed at a time. Offences
        ///  are handled sequentially, with their associated slashes computed and stored in
        ///  `UnappliedSlashes`. These slashes are then applied in a future era as determined by
        ///  `SlashDeferDuration`.
        /// 
        ///  Any offences tied to an era older than `BondingDuration` are automatically dropped.
        ///  Processing always prioritizes the oldest era first.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.slashing.OffenceRecord> OffenceQueue(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.OffenceQueueParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.slashing.OffenceRecord>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OffenceQueueErasParams
        ///  Tracks the eras that contain offences in `OffenceQueue`, sorted from **earliest to latest**.
        /// 
        ///  - This ensures efficient retrieval of the oldest offence without iterating through
        ///  `OffenceQueue`.
        ///  - When a new offence is added to `OffenceQueue`, its era is **inserted in sorted order**
        ///  if not already present.
        ///  - When all offences for an era are processed, it is **removed** from this list.
        ///  - The maximum length of this vector is bounded by `BondingDuration`.
        /// 
        ///  This eliminates the need for expensive iteration and sorting when fetching the next offence
        ///  to process.
        /// </summary>
        public static string OffenceQueueErasParams()
        {
            return RequestGenerator.GetStorage("Staking", "OffenceQueueEras", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> OffenceQueueErasDefault
        /// Default value as hex string
        /// </summary>
        public static string OffenceQueueErasDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> OffenceQueueEras
        ///  Tracks the eras that contain offences in `OffenceQueue`, sorted from **earliest to latest**.
        /// 
        ///  - This ensures efficient retrieval of the oldest offence without iterating through
        ///  `OffenceQueue`.
        ///  - When a new offence is added to `OffenceQueue`, its era is **inserted in sorted order**
        ///  if not already present.
        ///  - When all offences for an era are processed, it is **removed** from this list.
        ///  - The maximum length of this vector is bounded by `BondingDuration`.
        /// 
        ///  This eliminates the need for expensive iteration and sorting when fetching the next offence
        ///  to process.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.weak_bounded_vec.WeakBoundedVecT4> OffenceQueueEras(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.OffenceQueueErasParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.weak_bounded_vec.WeakBoundedVecT4>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ProcessingOffenceParams
        ///  Tracks the currently processed offence record from the `OffenceQueue`.
        /// 
        ///  - When processing offences, an offence record is **popped** from the oldest era in
        ///    `OffenceQueue` and stored here.
        ///  - The function `process_offence` reads from this storage, processing one page of exposure at
        ///    a time.
        ///  - After processing a page, the `exposure_page` count is **decremented** until it reaches
        ///    zero.
        ///  - Once fully processed, the offence record is removed from this storage.
        /// 
        ///  This ensures that offences are processed incrementally, preventing excessive computation
        ///  in a single block while maintaining correct slashing behavior.
        /// </summary>
        public static string ProcessingOffenceParams()
        {
            return RequestGenerator.GetStorage("Staking", "ProcessingOffence", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ProcessingOffenceDefault
        /// Default value as hex string
        /// </summary>
        public static string ProcessingOffenceDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ProcessingOffence
        ///  Tracks the currently processed offence record from the `OffenceQueue`.
        /// 
        ///  - When processing offences, an offence record is **popped** from the oldest era in
        ///    `OffenceQueue` and stored here.
        ///  - The function `process_offence` reads from this storage, processing one page of exposure at
        ///    a time.
        ///  - After processing a page, the `exposure_page` count is **decremented** until it reaches
        ///    zero.
        ///  - Once fully processed, the offence record is removed from this storage.
        /// 
        ///  This ensures that offences are processed incrementally, preventing excessive computation
        ///  in a single block while maintaining correct slashing behavior.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.slashing.OffenceRecord>> ProcessingOffence(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ProcessingOffenceParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.slashing.OffenceRecord>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UnappliedSlashesParams
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public static string UnappliedSlashesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U32>> key)
        {
            return RequestGenerator.GetStorage("Staking", "UnappliedSlashes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> UnappliedSlashesDefault
        /// Default value as hex string
        /// </summary>
        public static string UnappliedSlashesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.UnappliedSlash> UnappliedSlashes(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U32>> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.UnappliedSlashesParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.UnappliedSlash>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CancelledSlashesParams
        ///  Cancelled slashes by era and validator with maximum slash fraction to be cancelled.
        /// 
        ///  When slashes are cancelled by governance, this stores the era and the validators
        ///  whose slashes should be cancelled, along with the maximum slash fraction that should
        ///  be cancelled for each validator.
        /// </summary>
        public static string CancelledSlashesParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "CancelledSlashes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CancelledSlashesDefault
        /// Default value as hex string
        /// </summary>
        public static string CancelledSlashesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CancelledSlashes
        ///  Cancelled slashes by era and validator with maximum slash fraction to be cancelled.
        /// 
        ///  When slashes are cancelled by governance, this stores the era and the validators
        ///  whose slashes should be cancelled, along with the maximum slash fraction that should
        ///  be cancelled for each validator.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT66> CancelledSlashes(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CancelledSlashesParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT66>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ValidatorSlashInEraParams
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public static string ValidatorSlashInEraParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorSlashInEra", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorSlashInEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEra(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorSlashInEraParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ChillThresholdParams
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public static string ChillThresholdParams()
        {
            return RequestGenerator.GetStorage("Staking", "ChillThreshold", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ChillThresholdDefault
        /// Default value as hex string
        /// </summary>
        public static string ChillThresholdDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent> ChillThreshold(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ChillThresholdParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> VoterSnapshotStatusParams
        ///  Voter snapshot progress status.
        /// 
        ///  If the status is `Ongoing`, it keeps a cursor of the last voter retrieved to proceed when
        ///  creating the next snapshot page.
        /// </summary>
        public static string VoterSnapshotStatusParams()
        {
            return RequestGenerator.GetStorage("Staking", "VoterSnapshotStatus", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> VoterSnapshotStatusDefault
        /// Default value as hex string
        /// </summary>
        public static string VoterSnapshotStatusDefault()
        {
            return "0x02";
        }
        
        /// <summary>
        /// >> VoterSnapshotStatus
        ///  Voter snapshot progress status.
        /// 
        ///  If the status is `Ongoing`, it keeps a cursor of the last voter retrieved to proceed when
        ///  creating the next snapshot page.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumSnapshotStatus> VoterSnapshotStatus(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.VoterSnapshotStatusParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumSnapshotStatus>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NextElectionPageParams
        ///  Keeps track of an ongoing multi-page election solution request.
        /// 
        ///  If `Some(_)``, it is the next page that we intend to elect. If `None`, we are not in the
        ///  election process.
        /// 
        ///  This is only set in multi-block elections. Should always be `None` otherwise.
        /// </summary>
        public static string NextElectionPageParams()
        {
            return RequestGenerator.GetStorage("Staking", "NextElectionPage", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> NextElectionPageDefault
        /// Default value as hex string
        /// </summary>
        public static string NextElectionPageDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> NextElectionPage
        ///  Keeps track of an ongoing multi-page election solution request.
        /// 
        ///  If `Some(_)``, it is the next page that we intend to elect. If `None`, we are not in the
        ///  election process.
        /// 
        ///  This is only set in multi-block elections. Should always be `None` otherwise.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> NextElectionPage(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.NextElectionPageParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ElectableStashesParams
        ///  A bounded list of the "electable" stashes that resulted from a successful election.
        /// </summary>
        public static string ElectableStashesParams()
        {
            return RequestGenerator.GetStorage("Staking", "ElectableStashes", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ElectableStashesDefault
        /// Default value as hex string
        /// </summary>
        public static string ElectableStashesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ElectableStashes
        ///  A bounded list of the "electable" stashes that resulted from a successful election.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_btree_set.BoundedBTreeSetT3> ElectableStashes(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ElectableStashesParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_btree_set.BoundedBTreeSetT3>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> EraPruningStateParams
        ///  Tracks the current step of era pruning process for each era being lazily pruned.
        /// </summary>
        public static string EraPruningStateParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "EraPruningState", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> EraPruningStateDefault
        /// Default value as hex string
        /// </summary>
        public static string EraPruningStateDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> EraPruningState
        ///  Tracks the current step of era pruning process for each era being lazily pruned.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumPruningStep> EraPruningState(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.EraPruningStateParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumPruningStep>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> StakingCalls
    /// </summary>
    public sealed class StakingCalls
    {
        
        /// <summary>
        /// >> bond
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Bond(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            byteArray.AddRange(payee.Encode());
            return new Method(89, "Staking", 0, "bond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bond_extra
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method BondExtra(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> max_additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(max_additional.Encode());
            return new Method(89, "Staking", 1, "bond_extra", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unbond
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Unbond(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(89, "Staking", 2, "unbond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method WithdrawUnbonded(Substrate.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(89, "Staking", 3, "withdraw_unbonded", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> validate
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Validate(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs prefs)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(prefs.Encode());
            return new Method(89, "Staking", 4, "validate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> nominate
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Nominate(Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> targets)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(targets.Encode());
            return new Method(89, "Staking", 5, "nominate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Chill()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(89, "Staking", 6, "chill", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_payee
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetPayee(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(payee.Encode());
            return new Method(89, "Staking", 7, "set_payee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_controller
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetController()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(89, "Staking", 8, "set_controller", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_validator_count
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetValidatorCount(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(@new.Encode());
            return new Method(89, "Staking", 9, "set_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> increase_validator_count
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method IncreaseValidatorCount(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(additional.Encode());
            return new Method(89, "Staking", 10, "increase_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> scale_validator_count
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ScaleValidatorCount(PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent factor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(factor.Encode());
            return new Method(89, "Staking", 11, "scale_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_no_eras
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceNoEras()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(89, "Staking", 12, "force_no_eras", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceNewEra()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(89, "Staking", 13, "force_new_era", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_invulnerables
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetInvulnerables(Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> invulnerables)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(invulnerables.Encode());
            return new Method(89, "Staking", 14, "set_invulnerables", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_unstake
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceUnstake(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash, Substrate.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(89, "Staking", 15, "force_unstake", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era_always
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceNewEraAlways()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(89, "Staking", 16, "force_new_era_always", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_deferred_slash
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CancelDeferredSlash(Substrate.NetApi.Model.Types.Primitive.U32 era, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>> validator_slashes)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(era.Encode());
            byteArray.AddRange(validator_slashes.Encode());
            return new Method(89, "Staking", 17, "cancel_deferred_slash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> payout_stakers
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method PayoutStakers(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 validator_stash, Substrate.NetApi.Model.Types.Primitive.U32 era)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            byteArray.AddRange(era.Encode());
            return new Method(89, "Staking", 18, "payout_stakers", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> rebond
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Rebond(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(89, "Staking", 19, "rebond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> reap_stash
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ReapStash(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash, Substrate.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(89, "Staking", 20, "reap_stash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kick
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Kick(Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> who)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(who.Encode());
            return new Method(89, "Staking", 21, "kick", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_staking_configs
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetStakingConfigs(PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp min_nominator_bond, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp min_validator_bond, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp max_nominator_count, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp max_validator_count, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp chill_threshold, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp min_commission, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp max_staked_rewards)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(min_nominator_bond.Encode());
            byteArray.AddRange(min_validator_bond.Encode());
            byteArray.AddRange(max_nominator_count.Encode());
            byteArray.AddRange(max_validator_count.Encode());
            byteArray.AddRange(chill_threshold.Encode());
            byteArray.AddRange(min_commission.Encode());
            byteArray.AddRange(max_staked_rewards.Encode());
            return new Method(89, "Staking", 22, "set_staking_configs", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill_other
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ChillOther(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            return new Method(89, "Staking", 23, "chill_other", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_apply_min_commission
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceApplyMinCommission(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 validator_stash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            return new Method(89, "Staking", 24, "force_apply_min_commission", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_min_commission
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetMinCommission(PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(@new.Encode());
            return new Method(89, "Staking", 25, "set_min_commission", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> payout_stakers_by_page
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method PayoutStakersByPage(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 validator_stash, Substrate.NetApi.Model.Types.Primitive.U32 era, Substrate.NetApi.Model.Types.Primitive.U32 page)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            byteArray.AddRange(era.Encode());
            byteArray.AddRange(page.Encode());
            return new Method(89, "Staking", 26, "payout_stakers_by_page", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_payee
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdatePayee(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 controller)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            return new Method(89, "Staking", 27, "update_payee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> deprecate_controller_batch
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method DeprecateControllerBatch(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT18 controllers)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controllers.Encode());
            return new Method(89, "Staking", 28, "deprecate_controller_batch", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> restore_ledger
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RestoreLedger(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash, Substrate.NetApi.Model.Types.Base.BaseOpt<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32> maybe_controller, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_total, Substrate.NetApi.Model.Types.Base.BaseOpt<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19> maybe_unlocking)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(maybe_controller.Encode());
            byteArray.AddRange(maybe_total.Encode());
            byteArray.AddRange(maybe_unlocking.Encode());
            return new Method(89, "Staking", 29, "restore_ledger", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> migrate_currency
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method MigrateCurrency(PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            return new Method(89, "Staking", 30, "migrate_currency", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> apply_slash
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ApplySlash(Substrate.NetApi.Model.Types.Primitive.U32 slash_era, Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U32> slash_key)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(slash_era.Encode());
            byteArray.AddRange(slash_key.Encode());
            return new Method(89, "Staking", 31, "apply_slash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> prune_era_step
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method PruneEraStep(Substrate.NetApi.Model.Types.Primitive.U32 era)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(era.Encode());
            return new Method(89, "Staking", 32, "prune_era_step", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> StakingConstants
    /// </summary>
    public sealed class StakingConstants
    {
        
        /// <summary>
        /// >> HistoryDepth
        ///  Number of eras to keep in history.
        /// 
        ///  Following information is kept for eras in `[current_era -
        ///  HistoryDepth, current_era]`: `ErasValidatorPrefs`, `ErasValidatorReward`,
        ///  `ErasRewardPoints`, `ErasTotalStake`, `ClaimedRewards`,
        ///  `ErasStakersPaged`, `ErasStakersOverview`.
        /// 
        ///  Must be more than the number of eras delayed by session.
        ///  I.e. active era must always be in history. I.e. `active_era >
        ///  current_era - history_depth` must be guaranteed.
        /// 
        ///  If migrating an existing pallet from storage value to config value,
        ///  this should be set to same value or greater as in storage.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 HistoryDepth()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x54000000");
            return result;
        }
        
        /// <summary>
        /// >> SessionsPerEra
        ///  Number of sessions per era, as per the preferences of the **relay chain**.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 SessionsPerEra()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x06000000");
            return result;
        }
        
        /// <summary>
        /// >> PlanningEraOffset
        ///  Number of sessions before the end of an era when the election for the next era will
        ///  start.
        /// 
        ///  - This determines how many sessions **before** the last session of the era the staking
        ///    election process should begin.
        ///  - The value is bounded between **1** (election starts at the beginning of the last
        ///    session) and `SessionsPerEra` (election starts at the beginning of the first session
        ///    of the era).
        /// 
        ///  ### Example:
        ///  - If `SessionsPerEra = 6` and `PlanningEraOffset = 1`, the election starts at the
        ///    beginning of session `6 - 1 = 5`.
        ///  - If `PlanningEraOffset = 6`, the election starts at the beginning of session `6 - 6 =
        ///    0`, meaning it starts at the very beginning of the era.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 PlanningEraOffset()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x02000000");
            return result;
        }
        
        /// <summary>
        /// >> BondingDuration
        ///  Number of eras that staked funds must remain bonded for.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 BondingDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x1C000000");
            return result;
        }
        
        /// <summary>
        /// >> SlashDeferDuration
        ///  Number of eras that slashes are deferred by, after computation.
        /// 
        ///  This should be less than the bonding duration. Set to 0 if slashes
        ///  should be applied immediately, without opportunity for intervention.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 SlashDeferDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x1B000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxExposurePageSize
        ///  The maximum size of each `T::ExposurePage`.
        /// 
        ///  An `ExposurePage` is weakly bounded to a maximum of `MaxExposurePageSize`
        ///  nominators.
        /// 
        ///  For older non-paged exposure, a reward payout was restricted to the top
        ///  `MaxExposurePageSize` nominators. This is to limit the i/o cost for the
        ///  nominator payout.
        /// 
        ///  Note: `MaxExposurePageSize` is used to bound `ClaimedRewards` and is unsafe to
        ///  reduce without handling it in a migration.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxExposurePageSize()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00020000");
            return result;
        }
        
        /// <summary>
        /// >> MaxValidatorSet
        ///  The absolute maximum of winner validators this pallet should return.
        /// 
        ///  As this pallet supports multi-block election, the set of winner validators *per
        ///  election* is bounded by this type.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxValidatorSet()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xE8030000");
            return result;
        }
        
        /// <summary>
        /// >> MaxUnlockingChunks
        ///  The maximum number of `unlocking` chunks a [`StakingLedger`] can
        ///  have. Effectively determines how many unique eras a staker may be
        ///  unbonding in.
        /// 
        ///  Note: `MaxUnlockingChunks` is used as the upper bound for the
        ///  `BoundedVec` item `StakingLedger.unlocking`. Setting this value
        ///  lower than the existing value can lead to inconsistencies in the
        ///  `StakingLedger` and will need to be handled properly in a runtime
        ///  migration. The test `reducing_max_unlocking_chunks_abrupt` shows
        ///  this effect.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxUnlockingChunks()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x20000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxInvulnerables
        ///  Maximum number of invulnerable validators.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxInvulnerables()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x14000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxEraDuration
        ///  Maximum allowed era duration in milliseconds.
        /// 
        ///  This provides a defensive upper bound to cap the effective era duration, preventing
        ///  excessively long eras from causing runaway inflation (e.g., due to bugs). If the actual
        ///  era duration exceeds this value, it will be clamped to this maximum.
        /// 
        ///  Example: For an ideal era duration of 24 hours (86,400,000 ms),
        ///  this can be set to 604,800,000 ms (7 days).
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U64 MaxEraDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U64();
            result.Create("0x008AB90700000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxPruningItems
        ///  Maximum number of storage items that can be pruned in a single call.
        /// 
        ///  This controls how many storage items can be deleted in each call to `prune_era_step`.
        ///  This should be set to a conservative value (e.g., 100-500 items) to ensure pruning
        ///  doesn't consume too much block space. The actual weight is determined by benchmarks.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxPruningItems()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x64000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> StakingErrors
    /// </summary>
    public enum StakingErrors
    {
        
        /// <summary>
        /// >> NotController
        /// Not a controller account.
        /// </summary>
        NotController,
        
        /// <summary>
        /// >> NotStash
        /// Not a stash account.
        /// </summary>
        NotStash,
        
        /// <summary>
        /// >> AlreadyBonded
        /// Stash is already bonded.
        /// </summary>
        AlreadyBonded,
        
        /// <summary>
        /// >> AlreadyPaired
        /// Controller is already paired.
        /// </summary>
        AlreadyPaired,
        
        /// <summary>
        /// >> EmptyTargets
        /// Targets cannot be empty.
        /// </summary>
        EmptyTargets,
        
        /// <summary>
        /// >> DuplicateIndex
        /// Duplicate index.
        /// </summary>
        DuplicateIndex,
        
        /// <summary>
        /// >> InvalidSlashRecord
        /// Slash record not found.
        /// </summary>
        InvalidSlashRecord,
        
        /// <summary>
        /// >> InsufficientBond
        /// Cannot bond, nominate or validate with value less than the minimum defined by
        /// governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
        /// intention, `chill` first to remove one's role as validator/nominator.
        /// </summary>
        InsufficientBond,
        
        /// <summary>
        /// >> NoMoreChunks
        /// Can not schedule more unlock chunks.
        /// </summary>
        NoMoreChunks,
        
        /// <summary>
        /// >> NoUnlockChunk
        /// Can not rebond without unlocking chunks.
        /// </summary>
        NoUnlockChunk,
        
        /// <summary>
        /// >> FundedTarget
        /// Attempting to target a stash that still has funds.
        /// </summary>
        FundedTarget,
        
        /// <summary>
        /// >> InvalidEraToReward
        /// Invalid era to reward.
        /// </summary>
        InvalidEraToReward,
        
        /// <summary>
        /// >> InvalidNumberOfNominations
        /// Invalid number of nominations.
        /// </summary>
        InvalidNumberOfNominations,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// Rewards for this era have already been claimed for this validator.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> InvalidPage
        /// No nominators exist on this page.
        /// </summary>
        InvalidPage,
        
        /// <summary>
        /// >> IncorrectHistoryDepth
        /// Incorrect previous history depth input provided.
        /// </summary>
        IncorrectHistoryDepth,
        
        /// <summary>
        /// >> BadState
        /// Internal state has become somehow corrupted and the operation cannot continue.
        /// </summary>
        BadState,
        
        /// <summary>
        /// >> TooManyTargets
        /// Too many nomination targets supplied.
        /// </summary>
        TooManyTargets,
        
        /// <summary>
        /// >> BadTarget
        /// A nomination target was supplied that was blocked or otherwise not a validator.
        /// </summary>
        BadTarget,
        
        /// <summary>
        /// >> CannotChillOther
        /// The user has enough bond and thus cannot be chilled forcefully by an external person.
        /// </summary>
        CannotChillOther,
        
        /// <summary>
        /// >> TooManyNominators
        /// There are too many nominators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyNominators,
        
        /// <summary>
        /// >> TooManyValidators
        /// There are too many validator candidates in the system. Governance needs to adjust the
        /// staking settings to keep things safe for the runtime.
        /// </summary>
        TooManyValidators,
        
        /// <summary>
        /// >> CommissionTooLow
        /// Commission is too low. Must be at least `MinCommission`.
        /// </summary>
        CommissionTooLow,
        
        /// <summary>
        /// >> BoundNotMet
        /// Some bound is not met.
        /// </summary>
        BoundNotMet,
        
        /// <summary>
        /// >> ControllerDeprecated
        /// Used when attempting to use deprecated controller account logic.
        /// </summary>
        ControllerDeprecated,
        
        /// <summary>
        /// >> CannotRestoreLedger
        /// Cannot reset a ledger.
        /// </summary>
        CannotRestoreLedger,
        
        /// <summary>
        /// >> RewardDestinationRestricted
        /// Provided reward destination is not allowed.
        /// </summary>
        RewardDestinationRestricted,
        
        /// <summary>
        /// >> NotEnoughFunds
        /// Not enough funds available to withdraw.
        /// </summary>
        NotEnoughFunds,
        
        /// <summary>
        /// >> VirtualStakerNotAllowed
        /// Operation not allowed for virtual stakers.
        /// </summary>
        VirtualStakerNotAllowed,
        
        /// <summary>
        /// >> CannotReapStash
        /// Stash could not be reaped as other pallet might depend on it.
        /// </summary>
        CannotReapStash,
        
        /// <summary>
        /// >> AlreadyMigrated
        /// The stake of this account is already migrated to `Fungible` holds.
        /// </summary>
        AlreadyMigrated,
        
        /// <summary>
        /// >> EraNotStarted
        /// Era not yet started.
        /// </summary>
        EraNotStarted,
        
        /// <summary>
        /// >> Restricted
        /// Account is restricted from participation in staking. This may happen if the account is
        /// staking in another way already, such as via pool.
        /// </summary>
        Restricted,
        
        /// <summary>
        /// >> UnappliedSlashesInPreviousEra
        /// Unapplied slashes in the recently concluded era is blocking this operation.
        /// See `Call::apply_slash` to apply them.
        /// </summary>
        UnappliedSlashesInPreviousEra,
        
        /// <summary>
        /// >> EraNotPrunable
        /// The era is not eligible for pruning.
        /// </summary>
        EraNotPrunable,
        
        /// <summary>
        /// >> CancelledSlash
        /// The slash has been cancelled and cannot be applied.
        /// </summary>
        CancelledSlash,
    }
}
