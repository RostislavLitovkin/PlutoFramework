//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace PolkadotAssetHub.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> MultiBlockElectionVerifierStorage
    /// </summary>
    public sealed class MultiBlockElectionVerifierStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> MultiBlockElectionVerifierStorage Constructor
        /// </summary>
        public MultiBlockElectionVerifierStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "QueuedSolutionX"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.frame_election_provider_support.BoundedSupports)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "QueuedSolutionY"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.frame_election_provider_support.BoundedSupports)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "QueuedValidVariant"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.verifier.impls.EnumValidSolution)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "QueuedSolutionBackings"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT62)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "QueuedSolutionScore"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "MinimumScore"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiBlockElectionVerifier", "StatusStorage"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.verifier.impls.EnumStatus)));
        }
        
        /// <summary>
        /// >> QueuedSolutionXParams
        ///  The `X` variant of the current queued solution. Might be the valid one or not.
        /// 
        ///  The two variants of this storage item is to avoid the need of copying. Recall that once a
        ///  `VerifyingSolution` is being processed, it needs to write its partial supports *somewhere*.
        ///  Writing theses supports on top of a *good* queued supports is wrong, since we might bail.
        ///  Writing them to a bugger and copying at the ned is slightly better, but expensive. This flag
        ///  system is best of both worlds.
        /// </summary>
        public static string QueuedSolutionXParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "QueuedSolutionX", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> QueuedSolutionXDefault
        /// Default value as hex string
        /// </summary>
        public static string QueuedSolutionXDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> QueuedSolutionX
        ///  The `X` variant of the current queued solution. Might be the valid one or not.
        /// 
        ///  The two variants of this storage item is to avoid the need of copying. Recall that once a
        ///  `VerifyingSolution` is being processed, it needs to write its partial supports *somewhere*.
        ///  Writing theses supports on top of a *good* queued supports is wrong, since we might bail.
        ///  Writing them to a bugger and copying at the ned is slightly better, but expensive. This flag
        ///  system is best of both worlds.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.frame_election_provider_support.BoundedSupports> QueuedSolutionX(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.QueuedSolutionXParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.frame_election_provider_support.BoundedSupports>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> QueuedSolutionYParams
        ///  The `Y` variant of the current queued solution. Might be the valid one or not.
        /// </summary>
        public static string QueuedSolutionYParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "QueuedSolutionY", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> QueuedSolutionYDefault
        /// Default value as hex string
        /// </summary>
        public static string QueuedSolutionYDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> QueuedSolutionY
        ///  The `Y` variant of the current queued solution. Might be the valid one or not.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.frame_election_provider_support.BoundedSupports> QueuedSolutionY(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.QueuedSolutionYParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.frame_election_provider_support.BoundedSupports>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> QueuedValidVariantParams
        ///  Pointer to the variant of [`QueuedSolutionX`] or [`QueuedSolutionY`] that is currently
        ///  valid.
        /// </summary>
        public static string QueuedValidVariantParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "QueuedValidVariant", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> QueuedValidVariantDefault
        /// Default value as hex string
        /// </summary>
        public static string QueuedValidVariantDefault()
        {
            return "0x01";
        }
        
        /// <summary>
        /// >> QueuedValidVariant
        ///  Pointer to the variant of [`QueuedSolutionX`] or [`QueuedSolutionY`] that is currently
        ///  valid.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.verifier.impls.EnumValidSolution> QueuedValidVariant(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.QueuedValidVariantParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.verifier.impls.EnumValidSolution>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> QueuedSolutionBackingsParams
        ///  The `(amount, count)` of backings, divided per page.
        /// 
        ///  This is stored because in the last block of verification we need them to compute the score,
        ///  and check `MaxBackersPerWinnerFinal`.
        /// 
        ///  This can only ever live for the invalid variant of the solution. Once it is valid, we don't
        ///  need this information anymore; the score is already computed once in
        ///  [`QueuedSolutionScore`], and the backing counts are checked.
        /// </summary>
        public static string QueuedSolutionBackingsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "QueuedSolutionBackings", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> QueuedSolutionBackingsDefault
        /// Default value as hex string
        /// </summary>
        public static string QueuedSolutionBackingsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> QueuedSolutionBackings
        ///  The `(amount, count)` of backings, divided per page.
        /// 
        ///  This is stored because in the last block of verification we need them to compute the score,
        ///  and check `MaxBackersPerWinnerFinal`.
        /// 
        ///  This can only ever live for the invalid variant of the solution. Once it is valid, we don't
        ///  need this information anymore; the score is already computed once in
        ///  [`QueuedSolutionScore`], and the backing counts are checked.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT62> QueuedSolutionBackings(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.QueuedSolutionBackingsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT62>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> QueuedSolutionScoreParams
        ///  The score of the valid variant of [`QueuedSolution`].
        /// 
        ///  This only ever lives for the `valid` variant.
        /// </summary>
        public static string QueuedSolutionScoreParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "QueuedSolutionScore", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> QueuedSolutionScoreDefault
        /// Default value as hex string
        /// </summary>
        public static string QueuedSolutionScoreDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> QueuedSolutionScore
        ///  The score of the valid variant of [`QueuedSolution`].
        /// 
        ///  This only ever lives for the `valid` variant.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore> QueuedSolutionScore(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.QueuedSolutionScoreParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinimumScoreParams
        ///  The minimum score that each solution must attain in order to be considered feasible.
        /// </summary>
        public static string MinimumScoreParams()
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "MinimumScore", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumScoreDefault
        /// Default value as hex string
        /// </summary>
        public static string MinimumScoreDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MinimumScore
        ///  The minimum score that each solution must attain in order to be considered feasible.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore> MinimumScore(string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.MinimumScoreParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.sp_npos_elections.ElectionScore>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> StatusStorageParams
        ///  Storage item for [`Status`].
        /// </summary>
        public static string StatusStorageParams()
        {
            return RequestGenerator.GetStorage("MultiBlockElectionVerifier", "StatusStorage", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> StatusStorageDefault
        /// Default value as hex string
        /// </summary>
        public static string StatusStorageDefault()
        {
            return "0x01";
        }
        
        /// <summary>
        /// >> StatusStorage
        ///  Storage item for [`Status`].
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.verifier.impls.EnumStatus> StatusStorage(string blockhash, CancellationToken token)
        {
            string parameters = MultiBlockElectionVerifierStorage.StatusStorageParams();
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_election_provider_multi_block.verifier.impls.EnumStatus>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> MultiBlockElectionVerifierCalls
    /// </summary>
    public sealed class MultiBlockElectionVerifierCalls
    {
    }
    
    /// <summary>
    /// >> MultiBlockElectionVerifierConstants
    /// </summary>
    public sealed class MultiBlockElectionVerifierConstants
    {
        
        /// <summary>
        /// >> SolutionImprovementThreshold
        ///  The minimum amount of improvement to the solution score that defines a solution as
        ///  "better".
        /// </summary>
        public PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill SolutionImprovementThreshold()
        {
            var result = new PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill();
            result.Create("0x00000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxBackersPerWinnerFinal
        ///  Maximum number of backers, per winner, among all pages of an election.
        /// 
        ///  This can only be checked at the very final step of verification.
        /// 
        ///  NOTE: at the moment, we don't check this, and it is in place for future compatibility.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxBackersPerWinnerFinal()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xE4570000");
            return result;
        }
        
        /// <summary>
        /// >> MaxBackersPerWinner
        ///  Maximum number of backers, per winner, per page.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxBackersPerWinner()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xC0020000");
            return result;
        }
        
        /// <summary>
        /// >> MaxWinnersPerPage
        ///  Maximum number of supports (aka. winners/validators/targets) that can be represented in
        ///  a page of results.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxWinnersPerPage()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xE8030000");
            return result;
        }
    }
}
