//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> bond
        /// Take the origin account as a stash and lock up `value` of its balance. `controller` will
        /// be the account that controls it.
        /// 
        /// `value` must be more than the `minimum_balance` specified by `T::Currency`.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the stash account.
        /// 
        /// Emits `Bonded`.
        /// 
        /// NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
        /// unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
        /// as dust.
        /// </summary>
        bond = 0,
        
        /// <summary>
        /// >> bond_extra
        /// Add some extra amount that have appeared in the stash `free_balance` into the balance up
        /// for staking.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
        /// 
        /// Use this if there are additional funds in your stash account that you wish to bond.
        /// Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
        /// any limitation on the amount that can be added.
        /// 
        /// Emits `Bonded`.
        /// </summary>
        bond_extra = 1,
        
        /// <summary>
        /// >> unbond
        /// Schedule a portion of the stash to be unlocked ready for transfer out after the bond
        /// period ends. If this leaves an amount actively bonded less than
        /// [`asset::existential_deposit`], then it is increased to the full amount.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// Once the unlock period is done, you can call `withdraw_unbonded` to actually move
        /// the funds out of management ready for transfer.
        /// 
        /// No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
        /// can co-exists at the same time. If there are no unlocking chunks slots available
        /// [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
        /// 
        /// If a user encounters the `InsufficientBond` error when calling this extrinsic,
        /// they should call `chill` first in order to free up their bonded funds.
        /// 
        /// Emits `Unbonded`.
        /// 
        /// See also [`Call::withdraw_unbonded`].
        /// </summary>
        unbond = 2,
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Remove any stake that has been fully unbonded and is ready for withdrawal.
        /// 
        /// Stake is considered fully unbonded once [`Config::BondingDuration`] has elapsed since
        /// the unbonding was initiated. In rare cases���such as when offences for the unbonded era
        /// have been reported but not yet processed���withdrawal is restricted to eras for which
        /// all offences have been processed.
        /// 
        /// The unlocked stake will be returned as free balance in the stash account.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller.
        /// 
        /// Emits `Withdrawn`.
        /// 
        /// See also [`Call::unbond`].
        /// 
        /// ## Parameters
        /// 
        /// - `num_slashing_spans`: **Deprecated**. Retained only for backward compatibility; this
        ///   parameter has no effect.
        /// </summary>
        withdraw_unbonded = 3,
        
        /// <summary>
        /// >> validate
        /// Declare the desire to validate for the origin controller.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// </summary>
        validate = 4,
        
        /// <summary>
        /// >> nominate
        /// Declare the desire to nominate `targets` for the origin controller.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// </summary>
        nominate = 5,
        
        /// <summary>
        /// >> chill
        /// Declare no desire to either validate or nominate.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// ## Complexity
        /// - Independent of the arguments. Insignificant complexity.
        /// - Contains one read.
        /// - Writes are limited to the `origin` account key.
        /// </summary>
        chill = 6,
        
        /// <summary>
        /// >> set_payee
        /// (Re-)set the payment target for a controller.
        /// 
        /// Effects will be felt instantly (as soon as this function is completed successfully).
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// </summary>
        set_payee = 7,
        
        /// <summary>
        /// >> set_controller
        /// (Re-)sets the controller of a stash to the stash itself. This function previously
        /// accepted a `controller` argument to set the controller to an account other than the
        /// stash itself. This functionality has now been removed, now only setting the controller
        /// to the stash, if it is not already.
        /// 
        /// Effects will be felt instantly (as soon as this function is completed successfully).
        /// 
        /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
        /// </summary>
        set_controller = 8,
        
        /// <summary>
        /// >> set_validator_count
        /// Sets the ideal number of validators.
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        set_validator_count = 9,
        
        /// <summary>
        /// >> increase_validator_count
        /// Increments the ideal number of validators up to maximum of
        /// `T::MaxValidatorSet`.
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        increase_validator_count = 10,
        
        /// <summary>
        /// >> scale_validator_count
        /// Scale up the ideal number of validators by a factor up to maximum of
        /// `T::MaxValidatorSet`.
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        scale_validator_count = 11,
        
        /// <summary>
        /// >> force_no_eras
        /// Force there to be no new eras indefinitely.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// # Warning
        /// 
        /// The election process starts multiple blocks before the end of the era.
        /// Thus the election process may be ongoing when this is called. In this case the
        /// election will continue until the next era is triggered.
        /// </summary>
        force_no_eras = 12,
        
        /// <summary>
        /// >> force_new_era
        /// Force there to be a new era at the end of the next session. After this, it will be
        /// reset to normal (non-forced) behaviour.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// # Warning
        /// 
        /// The election process starts multiple blocks before the end of the era.
        /// If this is called just before a new era is triggered, the election process may not
        /// have enough blocks to get a result.
        /// </summary>
        force_new_era = 13,
        
        /// <summary>
        /// >> set_invulnerables
        /// Set the validators who cannot be slashed (if any).
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        set_invulnerables = 14,
        
        /// <summary>
        /// >> force_unstake
        /// Force a current staker to become completely unstaked, immediately.
        /// 
        /// The dispatch origin must be Root.
        /// ## Parameters
        /// 
        /// - `stash`: The stash account to be unstaked.
        /// - `num_slashing_spans`: **Deprecated**. This parameter is retained for backward
        /// compatibility. It no longer has any effect.
        /// </summary>
        force_unstake = 15,
        
        /// <summary>
        /// >> force_new_era_always
        /// Force there to be a new era at the end of sessions indefinitely.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// # Warning
        /// 
        /// The election process starts multiple blocks before the end of the era.
        /// If this is called just before a new era is triggered, the election process may not
        /// have enough blocks to get a result.
        /// </summary>
        force_new_era_always = 16,
        
        /// <summary>
        /// >> cancel_deferred_slash
        /// Cancels scheduled slashes for a given era before they are applied.
        /// 
        /// This function allows `T::AdminOrigin` to cancel pending slashes for specified validators
        /// in a given era. The cancelled slashes are stored and will be checked when applying
        /// slashes.
        /// 
        /// ## Parameters
        /// - `era`: The staking era for which slashes should be cancelled. This is the era where
        ///   the slash would be applied, not the era in which the offence was committed.
        /// - `validator_slashes`: A list of validator stash accounts and their slash fractions to
        ///   be cancelled.
        /// </summary>
        cancel_deferred_slash = 17,
        
        /// <summary>
        /// >> payout_stakers
        /// Pay out next page of the stakers behind a validator for the given era.
        /// 
        /// - `validator_stash` is the stash account of the validator.
        /// - `era` may be any era between `[current_era - history_depth; current_era]`.
        /// 
        /// The origin of this call must be _Signed_. Any account can call this function, even if
        /// it is not one of the stakers.
        /// 
        /// The reward payout could be paged in case there are too many nominators backing the
        /// `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
        /// specific page, use `payout_stakers_by_page`.`
        /// 
        /// If all pages are claimed, it returns an error `InvalidPage`.
        /// </summary>
        payout_stakers = 18,
        
        /// <summary>
        /// >> rebond
        /// Rebond a portion of the stash scheduled to be unlocked.
        /// 
        /// The dispatch origin must be signed by the controller.
        /// </summary>
        rebond = 19,
        
        /// <summary>
        /// >> reap_stash
        /// Remove all data structures concerning a staker/stash once it is at a state where it can
        /// be considered `dust` in the staking system. The requirements are:
        /// 
        /// 1. the `total_balance` of the stash is below `min_chilled_bond` or is zero.
        /// 2. or, the `ledger.total` of the stash is below `min_chilled_bond` or is zero.
        /// 
        /// The former can happen in cases like a slash; the latter when a fully unbonded account
        /// is still receiving staking rewards in `RewardDestination::Staked`.
        /// 
        /// It can be called by anyone, as long as `stash` meets the above requirements.
        /// 
        /// Refunds the transaction fees upon successful execution.
        /// 
        /// ## Parameters
        /// 
        /// - `stash`: The stash account to be reaped.
        /// - `num_slashing_spans`: **Deprecated**. This parameter is retained for backward
        /// compatibility. It no longer has any effect.
        /// </summary>
        reap_stash = 20,
        
        /// <summary>
        /// >> kick
        /// Remove the given nominations from the calling validator.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// - `who`: A list of nominator stash accounts who are nominating this validator which
        ///   should no longer be nominating this validator.
        /// 
        /// Note: Making this call only makes sense if you first set the validator preferences to
        /// block any further nominations.
        /// </summary>
        kick = 21,
        
        /// <summary>
        /// >> set_staking_configs
        /// Update the various staking configurations .
        /// 
        /// * `min_nominator_bond`: The minimum active bond needed to be a nominator.
        /// * `min_validator_bond`: The minimum active bond needed to be a validator.
        /// * `max_nominator_count`: The max number of users who can be a nominator at once. When
        ///   set to `None`, no limit is enforced.
        /// * `max_validator_count`: The max number of users who can be a validator at once. When
        ///   set to `None`, no limit is enforced.
        /// * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
        ///   should be filled in order for the `chill_other` transaction to work.
        /// * `min_commission`: The minimum amount of commission that each validators must maintain.
        ///   This is checked only upon calling `validate`. Existing validators are not affected.
        /// 
        /// RuntimeOrigin must be Root to call this function.
        /// 
        /// NOTE: Existing nominators and validators will not be affected by this update.
        /// to kick people under the new limits, `chill_other` should be called.
        /// </summary>
        set_staking_configs = 22,
        
        /// <summary>
        /// >> chill_other
        /// Declare a `controller` to stop participating as either a validator or nominator.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_, but can be called by anyone.
        /// 
        /// If the caller is the same as the controller being targeted, then no further checks are
        /// enforced, and this function behaves just like `chill`.
        /// 
        /// If the caller is different than the controller being targeted, the following conditions
        /// must be met:
        /// 
        /// * `controller` must belong to a nominator who has become non-decodable,
        /// 
        /// Or:
        /// 
        /// * A `ChillThreshold` must be set and checked which defines how close to the max
        ///   nominators or validators we must reach before users can start chilling one-another.
        /// * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
        ///   how close we are to the threshold.
        /// * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
        ///   if this is a person that should be chilled because they have not met the threshold
        ///   bond required.
        /// 
        /// This can be helpful if bond requirements are updated, and we need to remove old users
        /// who do not satisfy these requirements.
        /// </summary>
        chill_other = 23,
        
        /// <summary>
        /// >> force_apply_min_commission
        /// Force a validator to have at least the minimum commission. This will not affect a
        /// validator who already has a commission greater than or equal to the minimum. Any account
        /// can call this.
        /// </summary>
        force_apply_min_commission = 24,
        
        /// <summary>
        /// >> set_min_commission
        /// Sets the minimum amount of commission that each validators must maintain.
        /// 
        /// This call has lower privilege requirements than `set_staking_config` and can be called
        /// by the `T::AdminOrigin`. Root can always call this.
        /// </summary>
        set_min_commission = 25,
        
        /// <summary>
        /// >> payout_stakers_by_page
        /// Pay out a page of the stakers behind a validator for the given era and page.
        /// 
        /// - `validator_stash` is the stash account of the validator.
        /// - `era` may be any era between `[current_era - history_depth; current_era]`.
        /// - `page` is the page index of nominators to pay out with value between 0 and
        ///   `num_nominators / T::MaxExposurePageSize`.
        /// 
        /// The origin of this call must be _Signed_. Any account can call this function, even if
        /// it is not one of the stakers.
        /// 
        /// If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
        /// them, then the list of nominators is paged, with each page being capped at
        /// [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
        /// the call needs to be made for each page separately in order for all the nominators
        /// backing a validator to receive the reward. The nominators are not sorted across pages
        /// and so it should not be assumed the highest staker would be on the topmost page and vice
        /// versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
        /// </summary>
        payout_stakers_by_page = 26,
        
        /// <summary>
        /// >> update_payee
        /// Migrates an account's `RewardDestination::Controller` to
        /// `RewardDestination::Account(controller)`.
        /// 
        /// Effects will be felt instantly (as soon as this function is completed successfully).
        /// 
        /// This will waive the transaction fee if the `payee` is successfully migrated.
        /// </summary>
        update_payee = 27,
        
        /// <summary>
        /// >> deprecate_controller_batch
        /// Updates a batch of controller accounts to their corresponding stash account if they are
        /// not the same. Ignores any controller accounts that do not exist, and does not operate if
        /// the stash and controller are already the same.
        /// 
        /// Effects will be felt instantly (as soon as this function is completed successfully).
        /// 
        /// The dispatch origin must be `T::AdminOrigin`.
        /// </summary>
        deprecate_controller_batch = 28,
        
        /// <summary>
        /// >> restore_ledger
        /// Restores the state of a ledger which is in an inconsistent state.
        /// 
        /// The requirements to restore a ledger are the following:
        /// * The stash is bonded; or
        /// * The stash is not bonded but it has a staking lock left behind; or
        /// * If the stash has an associated ledger and its state is inconsistent; or
        /// * If the ledger is not corrupted *but* its staking lock is out of sync.
        /// 
        /// The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
        /// ledger associated with the stash. If the input parameters are not set, the ledger will
        /// be reset values from on-chain state.
        /// </summary>
        restore_ledger = 29,
        
        /// <summary>
        /// >> migrate_currency
        /// Migrates permissionlessly a stash from locks to holds.
        /// 
        /// This removes the old lock on the stake and creates a hold on it atomically. If all
        /// stake cannot be held, the best effort is made to hold as much as possible. The remaining
        /// stake is removed from the ledger.
        /// 
        /// The fee is waived if the migration is successful.
        /// </summary>
        migrate_currency = 30,
        
        /// <summary>
        /// >> apply_slash
        /// Manually and permissionlessly applies a deferred slash for a given era.
        /// 
        /// Normally, slashes are automatically applied shortly after the start of the `slash_era`.
        /// The automatic application of slashes is handled by the pallet's internal logic, and it
        /// tries to apply one slash page per block of the era.
        /// If for some reason, one era is not enough for applying all slash pages, the remaining
        /// slashes need to be manually (permissionlessly) applied.
        /// 
        /// For a given era x, if at era x+1, slashes are still unapplied, all withdrawals get
        /// blocked, and these need to be manually applied by calling this function.
        /// This function exists as a **fallback mechanism** for this extreme situation, but we
        /// never expect to encounter this in normal scenarios.
        /// 
        /// The parameters for this call can be queried by looking at the `UnappliedSlashes` storage
        /// for eras older than the active era.
        /// 
        /// ## Parameters
        /// - `slash_era`: The staking era in which the slash was originally scheduled.
        /// - `slash_key`: A unique identifier for the slash, represented as a tuple:
        ///   - `stash`: The stash account of the validator being slashed.
        ///   - `slash_fraction`: The fraction of the stake that was slashed.
        ///   - `page_index`: The index of the exposure page being processed.
        /// 
        /// ## Behavior
        /// - The function is **permissionless**���anyone can call it.
        /// - The `slash_era` **must be the current era or a past era**.
        /// If it is in the future, the
        ///   call fails with `EraNotStarted`.
        /// - The fee is waived if the slash is successfully applied.
        /// 
        /// ## Future Improvement
        /// - Implement an **off-chain worker (OCW) task** to automatically apply slashes when there
        ///   is unused block space, improving efficiency.
        /// </summary>
        apply_slash = 31,
        
        /// <summary>
        /// >> prune_era_step
        /// Perform one step of era pruning to prevent PoV size exhaustion from unbounded deletions.
        /// 
        /// This extrinsic enables permissionless lazy pruning of era data by performing
        /// incremental deletion of storage items. Each call processes a limited number
        /// of items based on available block weight to avoid exceeding block limits.
        /// 
        /// Returns `Pays::No` when work is performed to incentivize regular maintenance.
        /// Anyone can call this to help maintain the chain's storage health.
        /// 
        /// The era must be eligible for pruning (older than HistoryDepth + 1).
        /// Check `EraPruningState` storage to see if an era needs pruning before calling.
        /// </summary>
        prune_era_step = 32,
    }
    
    /// <summary>
    /// >> 470 - Variant[pallet_staking_async.pallet.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination>>(Call.bond);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>(Call.bond_extra);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>(Call.unbond);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U32>(Call.withdraw_unbonded);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.ValidatorPrefs>(Call.validate);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>>(Call.nominate);
				AddTypeDecoder<BaseVoid>(Call.chill);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.EnumRewardDestination>(Call.set_payee);
				AddTypeDecoder<BaseVoid>(Call.set_controller);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32>>(Call.set_validator_count);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32>>(Call.increase_validator_count);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Percent>(Call.scale_validator_count);
				AddTypeDecoder<BaseVoid>(Call.force_no_eras);
				AddTypeDecoder<BaseVoid>(Call.force_new_era);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.set_invulnerables);
				AddTypeDecoder<BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.force_unstake);
				AddTypeDecoder<BaseVoid>(Call.force_new_era_always);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>>>>(Call.cancel_deferred_slash);
				AddTypeDecoder<BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.payout_stakers);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>(Call.rebond);
				AddTypeDecoder<BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.reap_stash);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>>(Call.kick);
				AddTypeDecoder<BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp, PolkadotAssetHub.NetApi.Generated.Model.pallet_staking_async.pallet.pallet.EnumConfigOp>>(Call.set_staking_configs);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>(Call.chill_other);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>(Call.force_apply_min_commission);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>(Call.set_min_commission);
				AddTypeDecoder<BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.payout_stakers_by_page);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>(Call.update_payee);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT18>(Call.deprecate_controller_batch);
				AddTypeDecoder<BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseOpt<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<PolkadotAssetHub.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19>>>(Call.restore_ledger);
				AddTypeDecoder<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32>(Call.migrate_currency);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U32>>>(Call.apply_slash);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U32>(Call.prune_era_step);
        }
    }
}
