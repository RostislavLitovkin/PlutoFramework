//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Polkadot.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> DelegatedStakingStorage
    /// </summary>
    public sealed class DelegatedStakingStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> DelegatedStakingStorage Constructor
        /// </summary>
        public DelegatedStakingStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("DelegatedStaking", "Delegators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Polkadot.NetApi.Generated.Model.pallet_delegated_staking.types.Delegation)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("DelegatedStaking", "CounterForDelegators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("DelegatedStaking", "Agents"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Polkadot.NetApi.Generated.Model.pallet_delegated_staking.types.AgentLedger)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("DelegatedStaking", "CounterForAgents"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
        }
        
        /// <summary>
        /// >> DelegatorsParams
        ///  Map of Delegators to their `Delegation`.
        /// 
        ///  Implementation note: We are not using a double map with `delegator` and `agent` account
        ///  as keys since we want to restrict delegators to delegate only to one account at a time.
        /// </summary>
        public static string DelegatorsParams(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("DelegatedStaking", "Delegators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> DelegatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string DelegatorsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Delegators
        ///  Map of Delegators to their `Delegation`.
        /// 
        ///  Implementation note: We are not using a double map with `delegator` and `agent` account
        ///  as keys since we want to restrict delegators to delegate only to one account at a time.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.pallet_delegated_staking.types.Delegation> Delegators(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = DelegatedStakingStorage.DelegatorsParams(key);
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.pallet_delegated_staking.types.Delegation>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForDelegatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForDelegatorsParams()
        {
            return RequestGenerator.GetStorage("DelegatedStaking", "CounterForDelegators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForDelegatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForDelegatorsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForDelegators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForDelegators(string blockhash, CancellationToken token)
        {
            string parameters = DelegatedStakingStorage.CounterForDelegatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AgentsParams
        ///  Map of `Agent` to their `Ledger`.
        /// </summary>
        public static string AgentsParams(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("DelegatedStaking", "Agents", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AgentsDefault
        /// Default value as hex string
        /// </summary>
        public static string AgentsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Agents
        ///  Map of `Agent` to their `Ledger`.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.pallet_delegated_staking.types.AgentLedger> Agents(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = DelegatedStakingStorage.AgentsParams(key);
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.pallet_delegated_staking.types.AgentLedger>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForAgentsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForAgentsParams()
        {
            return RequestGenerator.GetStorage("DelegatedStaking", "CounterForAgents", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForAgentsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForAgentsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForAgents
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForAgents(string blockhash, CancellationToken token)
        {
            string parameters = DelegatedStakingStorage.CounterForAgentsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> DelegatedStakingCalls
    /// </summary>
    public sealed class DelegatedStakingCalls
    {
    }
    
    /// <summary>
    /// >> DelegatedStakingConstants
    /// </summary>
    public sealed class DelegatedStakingConstants
    {
        
        /// <summary>
        /// >> PalletId
        ///  Injected identifier for the pallet.
        /// </summary>
        public Polkadot.NetApi.Generated.Model.frame_support.PalletId PalletId()
        {
            var result = new Polkadot.NetApi.Generated.Model.frame_support.PalletId();
            result.Create("0x70792F646C73746B");
            return result;
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  Fraction of the slash that is rewarded to the caller of pending slash to the agent.
        /// </summary>
        public Polkadot.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill SlashRewardFraction()
        {
            var result = new Polkadot.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill();
            result.Create("0x80969800");
            return result;
        }
    }
    
    /// <summary>
    /// >> DelegatedStakingErrors
    /// </summary>
    public enum DelegatedStakingErrors
    {
        
        /// <summary>
        /// >> NotAllowed
        /// The account cannot perform this operation.
        /// </summary>
        NotAllowed,
        
        /// <summary>
        /// >> AlreadyStaking
        /// An existing staker cannot perform this action.
        /// </summary>
        AlreadyStaking,
        
        /// <summary>
        /// >> InvalidRewardDestination
        /// Reward Destination cannot be same as `Agent` account.
        /// </summary>
        InvalidRewardDestination,
        
        /// <summary>
        /// >> InvalidDelegation
        /// Delegation conditions are not met.
        /// 
        /// Possible issues are
        /// 1) Cannot delegate to self,
        /// 2) Cannot delegate to multiple delegates.
        /// </summary>
        InvalidDelegation,
        
        /// <summary>
        /// >> NotEnoughFunds
        /// The account does not have enough funds to perform the operation.
        /// </summary>
        NotEnoughFunds,
        
        /// <summary>
        /// >> NotAgent
        /// Not an existing `Agent` account.
        /// </summary>
        NotAgent,
        
        /// <summary>
        /// >> NotDelegator
        /// Not a Delegator account.
        /// </summary>
        NotDelegator,
        
        /// <summary>
        /// >> BadState
        /// Some corruption in internal state.
        /// </summary>
        BadState,
        
        /// <summary>
        /// >> UnappliedSlash
        /// Unapplied pending slash restricts operation on `Agent`.
        /// </summary>
        UnappliedSlash,
        
        /// <summary>
        /// >> NothingToSlash
        /// `Agent` has no pending slash to be applied.
        /// </summary>
        NothingToSlash,
        
        /// <summary>
        /// >> WithdrawFailed
        /// Failed to withdraw amount from Core Staking.
        /// </summary>
        WithdrawFailed,
        
        /// <summary>
        /// >> NotSupported
        /// Operation not supported by this pallet.
        /// </summary>
        NotSupported,
    }
}
