//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace KusamaAssetHub.NetApi.Generated.Model.pallet_remote_proxy.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> remote_proxy
        /// Dispatch the given `call` from an account that the sender is authorised on a remote
        /// chain.
        /// 
        /// The dispatch origin for this call must be _Signed_.
        /// 
        /// Parameters:
        /// - `real`: The account that the proxy will make a call on behalf of.
        /// - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
        /// - `call`: The call to be made by the `real` account.
        /// - `proof`: The proof from the remote chain about the existence of the proxy.
        /// </summary>
        remote_proxy = 0,
        
        /// <summary>
        /// >> register_remote_proxy_proof
        /// Register a given remote proxy proof in the current [`dispatch_context`].
        /// 
        /// The registered remote proof can then be used later in the same context to execute a
        /// remote proxy call. This is for example useful when having a multisig operation. The
        /// multisig call can use [`Self::remote_proxy_with_registered_proof`] to get an approval by
        /// the members of the multisig. The final execution of the multisig call should be at least
        /// a batch of `register_remote_proxy_proof` and the multisig call that uses
        /// `remote_proxy_with_registered_proof`. This way the final approver can use a recent proof
        /// to prove the existence of the remote proxy. Otherwise it would require the multisig
        /// members to approve the call in [`Config::MaxStorageRootsToKeep`] amount of time.
        /// 
        /// It is supported to register multiple proofs, but the proofs need to be consumed in the
        /// reverse order as they were registered. Basically this means last in, first out.
        /// 
        /// The [`dispatch_context`] spans the entire lifetime of a transaction and every call in
        /// the transaction gets access to the same context.
        /// 
        /// # Example
        /// 
        /// ```ignore
        /// batch([
        ///     register_remote_proxy_proof,
        ///     as_multisig(remote_proxy_with_registered_proof(transfer))
        /// ])
        /// ```
        /// 
        /// As `proofs` can not be verified indefinitely (the time the storage roots are stored is
        /// limited) this function provides the possibility to provide a "fresh proof" at time of
        /// dispatch. As in the example above, this could be useful for multisig operation that
        /// depend on multiple members to approve a certain action, which can take multiple days.
        /// </summary>
        register_remote_proxy_proof = 1,
        
        /// <summary>
        /// >> remote_proxy_with_registered_proof
        /// Dispatch the given `call` from an account that the sender is authorised on a remote
        /// chain.
        /// 
        /// The dispatch origin for this call must be _Signed_. The difference to
        /// [`Self::remote_proxy`] is that the proof nees to registered before using
        /// [`Self::register_remote_proxy_proof`] (see for more information).
        /// 
        /// Parameters:
        /// - `real`: The account that the proxy will make a call on behalf of.
        /// - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
        /// - `call`: The call to be made by the `real` account.
        /// </summary>
        remote_proxy_with_registered_proof = 2,
    }
    
    /// <summary>
    /// >> 360 - Variant[pallet_remote_proxy.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<KusamaAssetHub.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseOpt<KusamaAssetHub.NetApi.Generated.Model.asset_hub_kusama_runtime.EnumProxyType>, KusamaAssetHub.NetApi.Generated.Model.asset_hub_kusama_runtime.EnumRuntimeCall, KusamaAssetHub.NetApi.Generated.Model.pallet_remote_proxy.pallet.EnumRemoteProxyProof>>(Call.remote_proxy);
				AddTypeDecoder<KusamaAssetHub.NetApi.Generated.Model.pallet_remote_proxy.pallet.EnumRemoteProxyProof>(Call.register_remote_proxy_proof);
				AddTypeDecoder<BaseTuple<KusamaAssetHub.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseOpt<KusamaAssetHub.NetApi.Generated.Model.asset_hub_kusama_runtime.EnumProxyType>, KusamaAssetHub.NetApi.Generated.Model.asset_hub_kusama_runtime.EnumRuntimeCall>>(Call.remote_proxy_with_registered_proof);
        }
    }
}
