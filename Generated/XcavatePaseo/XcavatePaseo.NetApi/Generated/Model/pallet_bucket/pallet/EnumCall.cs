//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace XcavatePaseo.NetApi.Generated.Model.pallet_bucket.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> create_namespace
        /// Create a new namespace.
        /// 
        /// The namespace is created with the given metadata.
        /// The metadata is used to store additional information about the namespace.
        /// If successful, the events `NamespaceCreated` and `ManagerAdded` will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to be created.
        /// - `metadata_input`: The metadata of the namespace to be created.
        /// </summary>
        create_namespace = 0,
        
        /// <summary>
        /// >> add_contributor
        /// Add a contributor to a bucket.
        /// 
        /// The contributor is added to the bucket with the given id.
        /// The contributor is allowed to write messages to the bucket.
        /// If successful, a `ContributorAdded` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket to which the contributor is added.
        /// - `contributor`: The id of the contributor to be added.
        /// </summary>
        add_contributor = 1,
        
        /// <summary>
        /// >> remove_contributor
        /// Remove a contributor from a bucket.
        /// 
        /// The contributor is removed from the bucket with the given id.
        /// The contributor is no longer allowed to write messages to the bucket.
        /// If successful, a `ContributorRemoved` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket from which the contributor is removed.
        /// - `contributor`: The id of the contributor to be removed.
        /// </summary>
        remove_contributor = 2,
        
        /// <summary>
        /// >> add_admin
        /// Add a new admin to a bucket.
        /// 
        /// The admin is added to the bucket with the given id.
        /// The admin is allowed to manage the bucket.
        /// If successful, a `AdminAdded` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket to which the admin is added.
        /// - `admin`: The id of the admin to be added.
        /// </summary>
        add_admin = 3,
        
        /// <summary>
        /// >> remove_admin
        /// Remove an admin from a bucket.
        /// 
        /// The admin is removed from the bucket with the given id.
        /// The admin is no longer allowed to manage the bucket.
        /// If successful, a `AdminRemoved` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket from which the admin is removed.
        /// - `admin`: The id of the admin to be removed.
        /// </summary>
        remove_admin = 4,
        
        /// <summary>
        /// >> add_manager
        /// Add a new manager to a namespace.
        /// 
        /// The manager is added to the namespace with the given id.
        /// The manager is allowed to manage the namespace.
        /// If successful, a `ManagerAdded` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the manager is added.
        /// - `new_manager`: The id of the manager to be added.
        /// </summary>
        add_manager = 5,
        
        /// <summary>
        /// >> remove_manager
        /// Remove a manager from a namespace.
        /// 
        /// The manager is removed from the namespace with the given id.
        /// The manager is no longer allowed to manage the namespace.
        /// If successful, a `ManagerRemoved` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace from which the manager is removed.
        /// - `old_manager`: The id of the manager to be removed.
        /// </summary>
        remove_manager = 6,
        
        /// <summary>
        /// >> create_bucket
        /// Create a new bucket.
        /// 
        /// The bucket is created with the given metadata.
        /// The metadata is used to store additional information about the bucket.
        /// If successful the event `BucketCreated` will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `metadata_input`: The metadata of the bucket to be created.
        /// </summary>
        create_bucket = 7,
        
        /// <summary>
        /// >> pause_writing
        /// Pause writing to a bucket.
        /// 
        /// The bucket is paused for writing.
        /// The bucket is locked and no new messages can not be written to it.
        /// Only admin can pause the bucket.
        /// If successful, a `PausedBucket` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket to be paused.
        /// </summary>
        pause_writing = 8,
        
        /// <summary>
        /// >> resume_writing
        /// Resume writing to a bucket.
        /// 
        /// The bucket is resumed for writing.
        /// The bucket is unlocked and new messages can be written to it.
        /// Only admin can resume the bucket.
        /// If successful, an `BucketWritableWithKey` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket to be resumed.
        /// - `new_encryption_key`: The new encryption key to be used for the bucket.
        /// </summary>
        resume_writing = 9,
        
        /// <summary>
        /// >> create_tag
        /// Create a new tag.
        /// 
        /// The tag is created with the content.
        /// Only Admin can create a tag.
        /// If successful, a `NewTag` event will be emitted.
        /// 
        /// # Parameters
        /// - `bucket_id`: The id of the bucket to which the tag belongs.
        /// - `new_tag`: The tag to be created.
        /// </summary>
        create_tag = 10,
        
        /// <summary>
        /// >> rotate_key
        /// Rotate the encryption key of a bucket.
        /// 
        /// The encryption key is rotated for the bucket with the given id.
        /// The bucket is unlocked and new messages can be written to it.
        /// Only admin can rotate the bucket key.
        /// If successful, an `BucketWritableWithKey` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket to be rotated.
        /// - `new_encryption_key`: The new encryption key to be used for the bucket.
        /// </summary>
        rotate_key = 11,
        
        /// <summary>
        /// >> write
        /// Write a new message to a bucket.
        /// 
        /// The message is created with the content.
        /// Only contributors can write a message to the bucket.
        /// If successful, a `NewMessage` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The id of the namespace to which the bucket belongs.
        /// - `bucket_id`: The id of the bucket to which the message belongs.
        /// - `message_input`: The message to be created.
        /// </summary>
        write = 12,
        
        /// <summary>
        /// >> force_remove_namespace
        /// Forcefully removes a namespace.
        /// 
        /// This function is only available for the force origin.
        /// It will remove the specified namespace. To avoid dangling buckets, all buckets
        /// within the namespace must be removed beforehand.
        /// If successful, a `NamespaceDeleted` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The ID of the namespace to be removed.
        /// </summary>
        force_remove_namespace = 13,
        
        /// <summary>
        /// >> force_remove_bucket
        /// Forcefully removes a bucket.
        /// 
        /// This function is only available for the force origin.
        /// It will remove the specified bucket. To avoid dangling messages, all messages
        /// within the bucket must be removed beforehand.
        /// If successful, a `BucketDeleted` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The ID of the namespace to which the bucket belongs.
        /// - `bucket_id`: The ID of the bucket to be removed.
        /// </summary>
        force_remove_bucket = 14,
        
        /// <summary>
        /// >> force_remove_message
        /// Forcefully removes a message.
        /// 
        /// This function is only available for the force origin.
        /// It will remove the specified message.
        /// If successful, a `MessageDeleted` event will be emitted.
        /// 
        /// # Parameters
        /// - `bucket_id`: The ID of the bucket to which the message belongs.
        /// - `message_id`: The ID of the message to be removed.
        /// </summary>
        force_remove_message = 15,
        
        /// <summary>
        /// >> force_add_manager
        /// Forcefully adds a manager to a namespace.
        /// 
        /// This function is only available for the force origin.
        /// It will add the specified manager to the namespace.
        /// If successful, a `ManagerAdded` event will be emitted.
        /// 
        /// # Parameters
        /// - `namespace_id`: The ID of the namespace to which the manager belongs.
        /// - `manager`: The ID of the manager to be added.
        /// </summary>
        force_add_manager = 16,
    }
    
    /// <summary>
    /// >> 376 - Variant[pallet_bucket.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.container_chain_template_simple_runtime.MetadataInputMock>>(Call.create_namespace);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.add_contributor);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.remove_contributor);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.add_admin);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.remove_admin);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.add_manager);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.remove_manager);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.container_chain_template_simple_runtime.MetadataInputMock>>(Call.create_bucket);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.pause_writing);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.resume_writing);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT11>>(Call.create_tag);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.rotate_key);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.pallet_bucket.types.MessageInput>>(Call.write);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.force_remove_namespace);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.force_remove_bucket);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.force_remove_message);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, XcavatePaseo.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.force_add_manager);
        }
    }
}
