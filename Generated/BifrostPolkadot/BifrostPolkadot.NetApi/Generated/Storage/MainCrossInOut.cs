//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace BifrostPolkadot.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> CrossInOutStorage
    /// </summary>
    public sealed class CrossInOutStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> CrossInOutStorage Constructor
        /// </summary>
        public CrossInOutStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CrossInOut", "CrossCurrencyRegistry"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CrossInOut", "IssueWhiteList"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId), typeof(BifrostPolkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT58)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CrossInOut", "RegisterWhiteList"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId), typeof(BifrostPolkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT58)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CrossInOut", "AccountToOuterMultilocation"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CrossInOut", "OuterMultilocationToAccount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation>), typeof(BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CrossInOut", "CrossingMinimumAmount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>)));
        }
        
        /// <summary>
        /// >> CrossCurrencyRegistryParams
        ///  To store currencies that support indirect cross-in and cross-out.
        /// </summary>
        public static string CrossCurrencyRegistryParams(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key)
        {
            return RequestGenerator.GetStorage("CrossInOut", "CrossCurrencyRegistry", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CrossCurrencyRegistryDefault
        /// Default value as hex string
        /// </summary>
        public static string CrossCurrencyRegistryDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CrossCurrencyRegistry
        ///  To store currencies that support indirect cross-in and cross-out.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple> CrossCurrencyRegistry(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key, string blockhash, CancellationToken token)
        {
            string parameters = CrossInOutStorage.CrossCurrencyRegistryParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> IssueWhiteListParams
        ///  Accounts in the whitelist can issue the corresponding Currency.
        /// </summary>
        public static string IssueWhiteListParams(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key)
        {
            return RequestGenerator.GetStorage("CrossInOut", "IssueWhiteList", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> IssueWhiteListDefault
        /// Default value as hex string
        /// </summary>
        public static string IssueWhiteListDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> IssueWhiteList
        ///  Accounts in the whitelist can issue the corresponding Currency.
        /// </summary>
        public async Task<BifrostPolkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT58> IssueWhiteList(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key, string blockhash, CancellationToken token)
        {
            string parameters = CrossInOutStorage.IssueWhiteListParams(key);
            var result = await _client.GetStorageAsync<BifrostPolkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT58>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RegisterWhiteListParams
        ///  Accounts in the whitelist can register the mapping between a multilocation and an accountId.
        /// </summary>
        public static string RegisterWhiteListParams(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key)
        {
            return RequestGenerator.GetStorage("CrossInOut", "RegisterWhiteList", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> RegisterWhiteListDefault
        /// Default value as hex string
        /// </summary>
        public static string RegisterWhiteListDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> RegisterWhiteList
        ///  Accounts in the whitelist can register the mapping between a multilocation and an accountId.
        /// </summary>
        public async Task<BifrostPolkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT58> RegisterWhiteList(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key, string blockhash, CancellationToken token)
        {
            string parameters = CrossInOutStorage.RegisterWhiteListParams(key);
            var result = await _client.GetStorageAsync<BifrostPolkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT58>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AccountToOuterMultilocationParams
        ///  Mapping a Bifrost account to a multilocation of a outer chain
        /// </summary>
        public static string AccountToOuterMultilocationParams(Substrate.NetApi.Model.Types.Base.BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("CrossInOut", "AccountToOuterMultilocation", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> AccountToOuterMultilocationDefault
        /// Default value as hex string
        /// </summary>
        public static string AccountToOuterMultilocationDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AccountToOuterMultilocation
        ///  Mapping a Bifrost account to a multilocation of a outer chain
        /// </summary>
        public async Task<BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation> AccountToOuterMultilocation(Substrate.NetApi.Model.Types.Base.BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = CrossInOutStorage.AccountToOuterMultilocationParams(key);
            var result = await _client.GetStorageAsync<BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OuterMultilocationToAccountParams
        ///  Mapping a multilocation of a outer chain to a Bifrost account
        /// </summary>
        public static string OuterMultilocationToAccountParams(Substrate.NetApi.Model.Types.Base.BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation> key)
        {
            return RequestGenerator.GetStorage("CrossInOut", "OuterMultilocationToAccount", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> OuterMultilocationToAccountDefault
        /// Default value as hex string
        /// </summary>
        public static string OuterMultilocationToAccountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> OuterMultilocationToAccount
        ///  Mapping a multilocation of a outer chain to a Bifrost account
        /// </summary>
        public async Task<BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32> OuterMultilocationToAccount(Substrate.NetApi.Model.Types.Base.BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation> key, string blockhash, CancellationToken token)
        {
            string parameters = CrossInOutStorage.OuterMultilocationToAccountParams(key);
            var result = await _client.GetStorageAsync<BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CrossingMinimumAmountParams
        ///  minimum crossin and crossout amount���crossinMinimum, crossoutMinimum���
        /// </summary>
        public static string CrossingMinimumAmountParams(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key)
        {
            return RequestGenerator.GetStorage("CrossInOut", "CrossingMinimumAmount", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CrossingMinimumAmountDefault
        /// Default value as hex string
        /// </summary>
        public static string CrossingMinimumAmountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CrossingMinimumAmount
        ///  minimum crossin and crossout amount���crossinMinimum, crossoutMinimum���
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>> CrossingMinimumAmount(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId key, string blockhash, CancellationToken token)
        {
            string parameters = CrossInOutStorage.CrossingMinimumAmountParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> CrossInOutCalls
    /// </summary>
    public sealed class CrossInOutCalls
    {
        
        /// <summary>
        /// >> cross_out
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CrossOut(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> amount)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            byteArray.AddRange(amount.Encode());
            return new Method(123, "CrossInOut", 1, "cross_out", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> register_linked_account
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RegisterLinkedAccount(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 who, BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation foreign_location)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            byteArray.AddRange(who.Encode());
            byteArray.AddRange(foreign_location.Encode());
            return new Method(123, "CrossInOut", 2, "register_linked_account", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> change_outer_linked_account
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ChangeOuterLinkedAccount(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id, BifrostPolkadot.NetApi.Generated.Model.xcm.v2.multilocation.MultiLocation foreign_location, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 account)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            byteArray.AddRange(foreign_location.Encode());
            byteArray.AddRange(account.Encode());
            return new Method(123, "CrossInOut", 3, "change_outer_linked_account", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> deregister_currency_for_cross_in_out
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method DeregisterCurrencyForCrossInOut(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            return new Method(123, "CrossInOut", 5, "deregister_currency_for_cross_in_out", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_to_register_whitelist
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method AddToRegisterWhitelist(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 account)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            byteArray.AddRange(account.Encode());
            return new Method(123, "CrossInOut", 8, "add_to_register_whitelist", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_from_register_whitelist
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RemoveFromRegisterWhitelist(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id, BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 account)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            byteArray.AddRange(account.Encode());
            return new Method(123, "CrossInOut", 9, "remove_from_register_whitelist", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_crossing_minimum_amount
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetCrossingMinimumAmount(BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId currency_id, Substrate.NetApi.Model.Types.Primitive.U128 cross_in_minimum, Substrate.NetApi.Model.Types.Primitive.U128 cross_out_minimum)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(currency_id.Encode());
            byteArray.AddRange(cross_in_minimum.Encode());
            byteArray.AddRange(cross_out_minimum.Encode());
            return new Method(123, "CrossInOut", 10, "set_crossing_minimum_amount", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> CrossInOutConstants
    /// </summary>
    public sealed class CrossInOutConstants
    {
        
        /// <summary>
        /// >> MaxLengthLimit
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxLengthLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xF4010000");
            return result;
        }
    }
    
    /// <summary>
    /// >> CrossInOutErrors
    /// </summary>
    public enum CrossInOutErrors
    {
        
        /// <summary>
        /// >> NotEnoughBalance
        /// Indicates that the balance is not sufficient for the requested operation.
        /// </summary>
        NotEnoughBalance,
        
        /// <summary>
        /// >> NotExist
        /// Indicates that the specified item does not exist.
        /// </summary>
        NotExist,
        
        /// <summary>
        /// >> NotAllowed
        /// Indicates that the operation is not allowed for the current context.
        /// </summary>
        NotAllowed,
        
        /// <summary>
        /// >> CurrencyNotSupportCrossInAndOut
        /// Indicates that the currency does not support crossing in and out.
        /// </summary>
        CurrencyNotSupportCrossInAndOut,
        
        /// <summary>
        /// >> NoMultilocationMapping
        /// Indicates that there is no mapping for the specified multilocation.
        /// </summary>
        NoMultilocationMapping,
        
        /// <summary>
        /// >> AlreadyExist
        /// Indicates that the item already exists.
        /// </summary>
        AlreadyExist,
        
        /// <summary>
        /// >> NoCrossingMinimumSet
        /// Indicates that there is no minimum crossing amount set for the operation.
        /// </summary>
        NoCrossingMinimumSet,
        
        /// <summary>
        /// >> AmountLowerThanMinimum
        /// Indicates that the specified amount is lower than the required minimum.
        /// </summary>
        AmountLowerThanMinimum,
        
        /// <summary>
        /// >> ListOverflow
        /// Indicates that the list has reached its maximum capacity.
        /// </summary>
        ListOverflow,
    }
}
