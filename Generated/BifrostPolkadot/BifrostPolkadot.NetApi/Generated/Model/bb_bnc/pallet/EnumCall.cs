//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace BifrostPolkadot.NetApi.Generated.Model.bb_bnc.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> set_config
        /// Set configuration.
        /// 
        /// Set the minimum number of tokens and minimum time that users can lock.
        /// 
        /// - `min_mint`: The minimum mint balance
        /// - `min_block`: The minimum lockup time
        /// </summary>
        set_config = 0,
        
        /// <summary>
        /// >> create_lock
        /// Create a lock.
        /// 
        /// If the signer already has a position, the position will not be extended. it will be
        /// created a new position until the maximum number of positions is reached.
        /// 
        /// - `value`: The amount of tokens to lock
        /// - `unlock_time`: The lockup time
        /// </summary>
        create_lock = 1,
        
        /// <summary>
        /// >> increase_amount
        /// Increase the lock amount.
        /// 
        /// If the signer does not have the position, it doesn't work and the position will not be
        /// created. Only the position existed and owned by the signer, the locking amount will be
        /// increased.
        /// 
        /// - `position`: The lock position
        /// - `value`: The amount of tokens to increase
        /// </summary>
        increase_amount = 2,
        
        /// <summary>
        /// >> increase_unlock_time
        /// Increase the unlock time.
        /// 
        /// If the signer does not have the position, it doesn't work and the position will not be
        /// created. Only the position existed and owned by the signer, the locking time will be
        /// increased.
        /// 
        /// - `position`: The lock position
        /// - `time`: Additional lock time
        /// </summary>
        increase_unlock_time = 3,
        
        /// <summary>
        /// >> withdraw
        /// Withdraw the locked tokens after unlock time.
        /// 
        /// - `position`: The lock position
        /// </summary>
        withdraw = 4,
        
        /// <summary>
        /// >> notify_rewards
        /// Notify rewards.
        /// 
        /// Set the incentive controller and rewards token type for future round. Reward duration
        /// should be one round interval. It will notify the rewards from incentive controller to
        /// the system account and start a new round immediately, and the next round will auto start
        /// at now + rewards_duration.
        /// 
        /// - `incentive_from`: The incentive controller
        /// - `rewards_duration`: The rewards duration
        /// - `rewards`: The rewards
        /// </summary>
        notify_rewards = 5,
        
        /// <summary>
        /// >> get_rewards
        /// Get rewards for the signer.
        /// </summary>
        get_rewards = 6,
        
        /// <summary>
        /// >> redeem_unlock
        /// Fast unlocking, handling fee applies
        /// 
        /// When users want to redeem early regardless of cost, they can use this call.
        /// 
        /// - `position`: The lock position
        /// </summary>
        redeem_unlock = 7,
        
        /// <summary>
        /// >> set_markup_coefficient
        /// Set markup configurations.
        /// 
        /// - `currency_id`: The token type
        /// - `markup`: The markup coefficient
        /// - `hardcap`: The markup hardcap
        /// </summary>
        set_markup_coefficient = 8,
        
        /// <summary>
        /// >> deposit_markup
        /// Deposit markup.
        /// 
        /// Deposit the token to the system account for the markup.
        /// 
        /// - `currency_id`: The token type
        /// - `value`: The amount of tokens to deposit
        /// </summary>
        deposit_markup = 9,
        
        /// <summary>
        /// >> withdraw_markup
        /// Withdraw markup.
        /// 
        /// Withdraw the token from the system account for the markup.
        /// 
        /// - `currency_id`: The token type
        /// </summary>
        withdraw_markup = 10,
        
        /// <summary>
        /// >> refresh
        /// Refresh the markup.
        /// 
        /// Any user can call this function to refresh the markup coefficient. The maximum number of
        /// accounts that can be refreshed in one execution is MarkupRefreshLimit.
        /// 
        /// - `currency_id`: The token type
        /// </summary>
        refresh = 11,
    }
    
    /// <summary>
    /// >> 457 - Variant[bb_bnc.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>>>(Call.set_config);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.create_lock);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.increase_amount);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.increase_unlock_time);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.withdraw);
				AddTypeDecoder<BaseTuple<BifrostPolkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseVec<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId>>>(Call.notify_rewards);
				AddTypeDecoder<BaseVoid>(Call.get_rewards);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.redeem_unlock);
				AddTypeDecoder<BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, BifrostPolkadot.NetApi.Generated.Model.sp_arithmetic.fixed_point.FixedU128, BifrostPolkadot.NetApi.Generated.Model.sp_arithmetic.fixed_point.FixedU128, BifrostPolkadot.NetApi.Generated.Model.sp_arithmetic.fixed_point.FixedU128>>(Call.set_markup_coefficient);
				AddTypeDecoder<BaseTuple<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.deposit_markup);
				AddTypeDecoder<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId>(Call.withdraw_markup);
				AddTypeDecoder<BifrostPolkadot.NetApi.Generated.Model.bifrost_primitives.currency.EnumCurrencyId>(Call.refresh);
        }
    }
}
