//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Kilt.NetApi.Generated.Model.parachain_staking.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> force_new_round
        /// Forces the start of the new round in the next block.
        /// 
        /// The new round will be enforced via <T as
        /// ShouldEndSession<_>>::should_end_session.
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        force_new_round = 0,
        
        /// <summary>
        /// >> set_inflation
        /// Set the annual inflation rate to derive per-round inflation.
        /// 
        /// The inflation details are considered valid if the annual reward rate
        /// is approximately the per-block reward rate multiplied by the
        /// estimated* total number of blocks per year.
        /// 
        /// The estimated average block time is twelve seconds.
        /// 
        /// NOTE: Iterates over CandidatePool and for each candidate over their
        /// delegators to update their rewards before the reward rates change.
        /// Needs to be improved when scaling up `MaxTopCandidates`.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// Emits `RoundInflationSet`.
        /// </summary>
        set_inflation = 1,
        
        /// <summary>
        /// >> set_max_selected_candidates
        /// Set the maximum number of collator candidates that can be selected
        /// at the beginning of each validation round.
        /// 
        /// Changes are not applied until the start of the next round.
        /// 
        /// The new value must be higher than the minimum allowed as set in the
        /// pallet's configuration.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// Emits `MaxSelectedCandidatesSet`.
        /// </summary>
        set_max_selected_candidates = 2,
        
        /// <summary>
        /// >> set_blocks_per_round
        /// Set the number of blocks each validation round lasts.
        /// 
        /// If the new value is less than the length of the current round, the
        /// system will immediately move to the next round in the next block.
        /// 
        /// The new value must be higher than the minimum allowed as set in the
        /// pallet's configuration.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// Emits `BlocksPerRoundSet`.
        /// </summary>
        set_blocks_per_round = 3,
        
        /// <summary>
        /// >> set_max_candidate_stake
        /// Set the maximal amount a collator can stake. Existing stakes are not
        /// changed.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// Emits `MaxCandidateStakeChanged`.
        /// </summary>
        set_max_candidate_stake = 4,
        
        /// <summary>
        /// >> force_remove_candidate
        /// Forcedly removes a collator candidate from the TopCandidates and
        /// clears all associated storage for the candidate and their
        /// delegators.
        /// 
        /// Prepares unstaking of the candidates and their delegators stake
        /// which can be unfreezed via `unlock_unstaked` after waiting at
        /// least `StakeDuration` many blocks. Also increments rewards for the
        /// collator and their delegators.
        /// 
        /// Increments rewards of candidate and their delegators.
        /// 
        /// Emits `CandidateRemoved`.
        /// </summary>
        force_remove_candidate = 5,
        
        /// <summary>
        /// >> join_candidates
        /// Join the set of collator candidates.
        /// 
        /// In the next blocks, if the collator candidate has enough funds
        /// staked to be included in any of the top `MaxSelectedCandidates`
        /// positions, it will be included in the set of potential authors that
        /// will be selected by the stake-weighted random selection function.
        /// 
        /// The staked funds of the new collator candidate are added to the
        /// total stake of the system.
        /// 
        /// The total amount of funds staked must be within the allowed range as
        /// set in the pallet's configuration.
        /// 
        /// The dispatch origin must not be already part of the collator
        /// candidates nor of the delegators set.
        /// 
        /// Emits `JoinedCollatorCandidates`.
        /// </summary>
        join_candidates = 6,
        
        /// <summary>
        /// >> init_leave_candidates
        /// Request to leave the set of collator candidates.
        /// 
        /// On success, the account is immediately removed from the candidate
        /// pool to prevent selection as a collator in future validation rounds,
        /// but unstaking of the funds is executed with a delay of
        /// `StakeDuration` blocks.
        /// 
        /// The exit request can be reversed by calling
        /// `cancel_leave_candidates`.
        /// 
        /// This operation affects the pallet's total stake amount. It is
        /// updated even though the funds of the candidate who signaled to leave
        /// are still locked for `ExitDelay` + `StakeDuration` more blocks.
        /// 
        /// NOTE 1: Upon starting a new session_i in `new_session`, the current
        /// top candidates are selected to be block authors for session_i+1. Any
        /// changes to the top candidates afterwards do not effect the set of
        /// authors for session_i+1.
        /// Thus, we have to make sure none of these collators can
        /// leave before session_i+1 ends by delaying their
        /// exit for `ExitDelay` many blocks.
        /// 
        /// NOTE 2: We do not increment rewards in this extrinsic as the
        /// candidate could still author blocks, and thus be eligible to receive
        /// rewards, until the end of the next session.
        /// 
        /// Emits `CollatorScheduledExit`.
        /// </summary>
        init_leave_candidates = 7,
        
        /// <summary>
        /// >> execute_leave_candidates
        /// Execute the network exit of a candidate who requested to leave at
        /// least `ExitQueueDelay` rounds ago. Prepares unstaking of the
        /// candidates and their delegators stake which can be unfreezed via
        /// `unlock_unstaked` after waiting at least `StakeDuration` many
        /// blocks.
        /// 
        /// Requires the candidate to previously have called
        /// `init_leave_candidates`.
        /// 
        /// The exit request can be reversed by calling
        /// `cancel_leave_candidates`.
        /// 
        /// NOTE: Iterates over CandidatePool for each candidate over their
        /// delegators to set rewards. Needs to be improved when scaling up
        /// `MaxTopCandidates`.
        /// 
        /// Emits `CollatorLeft`.
        /// </summary>
        execute_leave_candidates = 8,
        
        /// <summary>
        /// >> cancel_leave_candidates
        /// Revert the previously requested exit of the network of a collator
        /// candidate. On success, adds back the candidate to the TopCandidates
        /// and updates the collators.
        /// 
        /// Requires the candidate to previously have called
        /// `init_leave_candidates`.
        /// 
        /// Emits `CollatorCanceledExit`.
        /// </summary>
        cancel_leave_candidates = 9,
        
        /// <summary>
        /// >> candidate_stake_more
        /// Stake more funds for a collator candidate.
        /// 
        /// If not in the set of candidates, staking enough funds allows the
        /// account to be added to it. The larger amount of funds, the higher
        /// chances to be selected as the author of the next block.
        /// 
        /// This operation affects the pallet's total stake amount.
        /// 
        /// The resulting total amount of funds staked must be within the
        /// allowed range as set in the pallet's configuration.
        /// 
        /// Emits `CollatorStakedMore`.
        /// </summary>
        candidate_stake_more = 10,
        
        /// <summary>
        /// >> candidate_stake_less
        /// Stake less funds for a collator candidate.
        /// 
        /// If the new amount of staked fund is not large enough, the account
        /// could be removed from the set of collator candidates and not be
        /// considered for authoring the next blocks.
        /// 
        /// This operation affects the pallet's total stake amount.
        /// 
        /// The unstaked funds are not released immediately to the account, but
        /// they will be available after `StakeDuration` blocks.
        /// 
        /// The resulting total amount of funds staked must be within the
        /// allowed range as set in the pallet's configuration.
        /// 
        /// Emits `CollatorStakedLess`.
        /// </summary>
        candidate_stake_less = 11,
        
        /// <summary>
        /// >> join_delegators
        /// Join the set of delegators by delegating to a collator candidate.
        /// 
        /// The account that wants to delegate cannot be part of the collator
        /// candidates set as well.
        /// 
        /// The caller must _not_ have a delegation. If that is the case, they
        /// are required to first remove the delegation.
        /// 
        /// The amount staked must be larger than the minimum required to become
        /// a delegator as set in the pallet's configuration.
        /// 
        /// As only `MaxDelegatorsPerCollator` are allowed to delegate a given
        /// collator, the amount staked must be larger than the lowest one in
        /// the current set of delegator for the operation to be meaningful.
        /// 
        /// The collator's total stake as well as the pallet's total stake are
        /// increased accordingly.
        /// 
        /// Emits `Delegation`.
        /// Emits `DelegationReplaced` if the candidate has
        /// `MaxDelegatorsPerCollator` many delegations but this delegator
        /// staked more than one of the other delegators of this candidate.
        /// </summary>
        join_delegators = 12,
        
        /// <summary>
        /// >> leave_delegators
        /// Leave the set of delegators and, by implication, revoke the ongoing
        /// delegation.
        /// 
        /// All staked funds are not unlocked immediately, but they are added to
        /// the queue of pending unstaking, and will effectively be released
        /// after `StakeDuration` blocks from the moment the delegator leaves.
        /// 
        /// This operation reduces the total stake of the pallet as well as the
        /// stakes of all collators that were delegated, potentially affecting
        /// their chances to be included in the set of candidates in the next
        /// rounds.
        /// 
        /// Automatically increments the accumulated rewards of the origin of
        /// the current delegation.
        /// 
        /// Emits `DelegatorLeft`.
        /// </summary>
        leave_delegators = 13,
        
        /// <summary>
        /// >> delegator_stake_more
        /// Increase the stake for delegating a collator candidate.
        /// 
        /// If not in the set of candidates, staking enough funds allows the
        /// collator candidate to be added to it.
        /// 
        /// Emits `DelegatorStakedMore`.
        /// </summary>
        delegator_stake_more = 14,
        
        /// <summary>
        /// >> delegator_stake_less
        /// Reduce the stake for delegating a collator candidate.
        /// 
        /// If the new amount of staked fund is not large enough, the collator
        /// could be removed from the set of collator candidates and not be
        /// considered for authoring the next blocks.
        /// 
        /// The unstaked funds are not release immediately to the account, but
        /// they will be available after `StakeDuration` blocks.
        /// 
        /// The remaining staked funds must still be larger than the minimum
        /// required by this pallet to maintain the status of delegator.
        /// 
        /// The resulting total amount of funds staked must be within the
        /// allowed range as set in the pallet's configuration.
        /// 
        /// Emits `DelegatorStakedLess`.
        /// </summary>
        delegator_stake_less = 15,
        
        /// <summary>
        /// >> unlock_unstaked
        /// Unlock all previously staked funds that are now available for
        /// unlocking by the origin account after `StakeDuration` blocks have
        /// elapsed.
        /// </summary>
        unlock_unstaked = 16,
        
        /// <summary>
        /// >> claim_rewards
        /// Claim block authoring rewards for the target address.
        /// 
        /// Requires `Rewards` to be set beforehand, which can by triggered by
        /// any of the following options
        /// * Calling increment_{collator, delegator}_rewards (active)
        /// * Altering your stake (active)
        /// * Leaving the network as a collator (active)
        /// * Revoking a delegation as a delegator (active)
        /// * Being a delegator whose collator left the network, altered their
        ///   stake or incremented rewards (passive)
        /// 
        /// The dispatch origin can be any signed one, e.g., anyone can claim
        /// for anyone.
        /// 
        /// Emits `Rewarded`.
        /// </summary>
        claim_rewards = 17,
        
        /// <summary>
        /// >> increment_collator_rewards
        /// Actively increment the rewards of a collator.
        /// 
        /// The same effect is triggered by changing the stake or leaving the
        /// network.
        /// 
        /// The dispatch origin must be a collator.
        /// </summary>
        increment_collator_rewards = 18,
        
        /// <summary>
        /// >> increment_delegator_rewards
        /// Actively increment the rewards of a delegator.
        /// 
        /// The same effect is triggered by changing the stake or revoking
        /// delegations.
        /// 
        /// The dispatch origin must be a delegator.
        /// </summary>
        increment_delegator_rewards = 19,
        
        /// <summary>
        /// >> execute_scheduled_reward_change
        /// Executes the annual reduction of the reward rates for collators and
        /// delegators.
        /// 
        /// Moreover, sets rewards for all collators and delegators
        /// before adjusting the inflation.
        /// 
        /// The dispatch origin can be any signed one because we bail if called
        /// too early.
        /// 
        /// Emits `RoundInflationSet`.
        /// </summary>
        execute_scheduled_reward_change = 20,
    }
    
    /// <summary>
    /// >> 315 - Variant[parachain_staking.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseVoid>(Call.force_new_round);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_arithmetic.per_things.Perquintill, Kilt.NetApi.Generated.Model.sp_arithmetic.per_things.Perquintill, Kilt.NetApi.Generated.Model.sp_arithmetic.per_things.Perquintill, Kilt.NetApi.Generated.Model.sp_arithmetic.per_things.Perquintill, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.set_inflation);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U32>(Call.set_max_selected_candidates);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U64>(Call.set_blocks_per_round);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.set_max_candidate_stake);
				AddTypeDecoder<Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>(Call.force_remove_candidate);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.join_candidates);
				AddTypeDecoder<BaseVoid>(Call.init_leave_candidates);
				AddTypeDecoder<Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>(Call.execute_leave_candidates);
				AddTypeDecoder<BaseVoid>(Call.cancel_leave_candidates);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.candidate_stake_more);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.candidate_stake_less);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.join_delegators);
				AddTypeDecoder<BaseVoid>(Call.leave_delegators);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.delegator_stake_more);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.delegator_stake_less);
				AddTypeDecoder<Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>(Call.unlock_unstaked);
				AddTypeDecoder<BaseVoid>(Call.claim_rewards);
				AddTypeDecoder<BaseVoid>(Call.increment_collator_rewards);
				AddTypeDecoder<BaseVoid>(Call.increment_delegator_rewards);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U32>(Call.execute_scheduled_reward_change);
        }
    }
}
