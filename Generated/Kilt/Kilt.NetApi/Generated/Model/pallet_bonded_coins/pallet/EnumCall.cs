//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Kilt.NetApi.Generated.Model.pallet_bonded_coins.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> create_pool
        /// Creates a new bonded token pool. The pool will be created with the
        /// given curve, collateral currency, and bonded currencies. The pool
        /// will be owned by the origin account.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call.
        /// - `curve`: The curve parameters for the pool.
        /// - `collateral_id`: The ID of the collateral currency.
        /// - `currencies`: A bounded vector of token metadata for the bonded
        ///   currencies. Note that no two currencies may use the same name or
        ///   symbol.
        /// - `currencies_settings`: Options and settings shared by all bonded
        ///   currencies. These cannot be changed after the pool is created.
        ///   - `denomination`: The denomination for the bonded currencies.
        ///   - `transferable`: A boolean indicating if the bonded currencies
        ///     are transferable.
        ///   - `allow_reset_team`: Whether asset management team changes are
        ///     allowed for this pool.
        ///   - `min_operation_balance`: The minimum amount that can be
        ///     minted/burnt.
        /// 
        /// # Returns
        /// - `DispatchResult`: The result of the dispatch.
        /// 
        /// # Errors
        /// - `Error::<T>::InvalidInput`: If either
        ///   - the denomination is greater than the maximum allowed
        ///   - the curve input is invalid
        ///   - two currencies use the same name or symbol
        /// - `Error::<T>::Internal`: If the conversion to `BoundedVec` fails.
        /// - Other errors depending on the types in the config.
        /// </summary>
        create_pool = 0,
        
        /// <summary>
        /// >> reset_team
        /// Changes the managing team of all bonded currencies issued by this
        /// pool, setting it to the provided `team`. The origin account must be
        /// a manager of the pool.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring the caller to be a
        ///   manager of the pool.
        /// - `pool_id`: The identifier of the pool.
        /// - `team`: The new managing team.
        /// - `currency_count`: The number of bonded currencies vector linked to
        ///   the pool. Required for weight estimations.
        /// 
        /// # Returns
        /// - `DispatchResult`: The result of the dispatch.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::NoPermission`: If this pool does not allow changing
        ///   the asset management team, or if the caller is not a manager of
        ///   the pool.
        /// - `Error::<T>::CurrencyCount`: If the actual number of currencies in
        ///   the pool is larger than `currency_count`.
        /// - Other errors depending on the types in the config.
        /// </summary>
        reset_team = 1,
        
        /// <summary>
        /// >> reset_manager
        /// Resets the manager of a pool. The new manager will be set to the
        /// provided account. If the new manager is `None`, the pool manager
        /// will be cleared, after which no further privileged changes to the
        /// pool can be made.
        /// The origin account must be a manager of the pool.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring the caller to be a
        ///   manager of the pool.
        /// - `pool_id`: The identifier of the pool.
        /// - `new_manager`: The new manager account. If `None`, the pool will
        ///   be set to permissionless.
        /// 
        /// # Returns
        /// - `DispatchResult`: The result of the dispatch.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::NoPermission`: If the caller is not a manager of the
        ///   pool.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in active or locked
        ///   state.
        /// </summary>
        reset_manager = 2,
        
        /// <summary>
        /// >> set_lock
        /// Locks a pool. The pool will be set to a locked state with the given
        /// locks. The origin account must be a manager of the pool.
        /// The pool must be in a locked or active state.
        /// The pool will be locked until the locks are removed.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring the caller to be a
        ///   manager of the pool.
        /// - `pool_id`: The identifier of the pool to be locked.
        /// - `lock`: The locks to be applied to the pool. At least one lock
        ///   flag must be set to `false` for a valid lock.
        /// 
        /// # Returns
        /// - `DispatchResult`: The result of the dispatch.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::NoPermission`: If the caller is not a manager of the
        ///   pool.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in a live (locked or
        ///   active) state.
        /// - `Error::<T>::InvalidInput`: If all lock flags are `true` (all
        ///   operations enabled), which would be equivalent to an unlocked
        ///   (active) pool state.
        /// </summary>
        set_lock = 3,
        
        /// <summary>
        /// >> unlock
        /// Unlocks a pool. The pool will be set to an active state. The origin
        /// account must be a manager of the pool.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring the caller to be a
        ///   manager of the pool.
        /// - `pool_id`: The identifier of the pool to be unlocked.
        /// 
        /// # Returns
        /// - `DispatchResult`: The result of the dispatch.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::NoPermission`: If the caller is not a manager of the
        ///   pool.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in a live state.
        /// </summary>
        unlock = 4,
        
        /// <summary>
        /// >> mint_into
        /// Mints new bonded tokens. The tokens will be minted into the
        /// beneficiary account. In exchange, an amount of collateral determined
        /// by the pool's bonding curve is debited from the caller and
        /// transferred to the pool account.
        /// The origin account must be a manager of the pool if its state is
        /// `Locked` and `allow_mint` is false. The pool must be in a live
        /// (non-refunding, non-destroying) state.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call.
        /// - `pool_id`: The identifier of the pool.
        /// - `currency_idx`: The index of the currency in the bonded currencies
        ///   vector.
        /// - `beneficiary`: The account to receive the minted tokens.
        /// - `amount_to_mint`: The amount of bonded tokens to mint.
        /// - `max_cost`: The maximum cost of collateral.
        /// - `currency_count`: The maximum number of currencies allowed in the
        ///   pool.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::NoPermission`: If the caller does not have permission
        ///   to mint.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `currency_count`.
        /// - `Error::<T>::IndexOutOfBounds`: If the currency index is out of
        ///   bounds.
        /// - `ArithmeticError::Overflow`: If there is an overflow during the
        ///   calculation.
        /// - `Error::<T>::Slippage`: If the cost exceeds `max_cost`.
        /// </summary>
        mint_into = 5,
        
        /// <summary>
        /// >> burn_into
        /// Burns a specified amount of bonded tokens from the callers account
        /// and transfers the corresponding collateral to the beneficiary.
        /// The amount of collateral to be transferred is calculated based on
        /// the amount of bonded tokens burned.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call.
        /// - `pool_id`: The identifier of the pool.
        /// - `currency_idx`: The index of the currency in the bonded currencies
        ///   vector.
        /// - `beneficiary`: The account to receive the collateral.
        /// - `amount_to_burn`: The amount of bonded tokens to burn.
        /// - `min_return`: The minimum amount of collateral to return.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::NoPermission`: If the caller does not have permission
        ///   to burn.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `currency_count`.
        /// - `Error::<T>::IndexOutOfBounds`: If the currency index is out of
        ///   bounds.
        /// - `ArithmeticError`: If there is an error during the calculation or
        ///   while converting the amount to fixed types.
        /// - `Error::<T>::Slippage`: If the collateral return is less than
        ///   `min_return`.
        /// </summary>
        burn_into = 6,
        
        /// <summary>
        /// >> start_refund
        /// Starts the refund process for a pool. The pool will be set to a
        /// refunding state. The origin account must be a manager of the pool.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring the caller to be a
        ///   manager of the pool.
        /// - `pool_id`: The identifier of the pool to start the refund process
        ///   for.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `max_currencies`.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in a live state.
        /// - `Error::<T>::NoPermission`: If the caller is not a manager of the
        ///   pool.
        /// - `Error::<T>::NothingToRefund`: If there is nothing to refund.
        /// </summary>
        start_refund = 8,
        
        /// <summary>
        /// >> force_start_refund
        /// Starts the refund process for a pool. The pool will be set to a
        /// refunding state. The origin requires force privileges.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring force privileges.
        /// - `pool_id`: The identifier of the pool to start the refund process
        ///   for.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `max_currencies`.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in a live state.
        /// - `Error::<T>::NoPermission`: If the caller is not a manager of the
        ///   pool.
        /// - `Error::<T>::NothingToRefund`: If there is nothing to refund.
        /// </summary>
        force_start_refund = 9,
        
        /// <summary>
        /// >> refund_account
        /// Refund an account. The account will be refunded with the collateral
        /// from the pool account.
        /// The amount of collateral to be refunded is calculated based on the
        /// amount of bonded tokens burned by the account in proportion to the
        /// total supply of bonded tokens.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call.
        /// - `pool_id`: The identifier of the pool.
        /// - `account`: The account to be refunded.
        /// - `asset_idx`: The index of the asset in the bonded currencies
        ///   vector.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `currency_count`.
        /// - `Error::<T>::NotRefunding`: If the pool is not in a refunding
        ///   state.
        /// - `Error::<T>::IndexOutOfBounds`: If the asset index is out of
        ///   bounds.
        /// - `Error::<T>::NothingToRefund`: If there is nothing to refund.
        ///   Either no collateral or the account has no bonded tokens.
        /// - `Error::<T>::Internal`: If there is an internal error during the
        ///   calculation.
        /// </summary>
        refund_account = 10,
        
        /// <summary>
        /// >> start_destroy
        /// Starts the destruction process for a pool. The pool will be set to a
        /// destroying state. The origin account must be a manager of the pool.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring the caller to be a
        ///   manager of the pool.
        /// - `pool_id`: The identifier of the pool to be destroyed.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `max_currencies`.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in a live or
        ///   refunding state.
        /// - `Error::<T>::NoPermission`: If the caller is not the owner or
        ///   manager of the pool.
        /// - `Error::<T>::LivePool`: If there are holders or collateral to
        ///   distribute.
        /// </summary>
        start_destroy = 11,
        
        /// <summary>
        /// >> force_start_destroy
        /// Starts the destruction process for a pool. The pool will be set to a
        /// destroying state. The origin requires force privileges.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call, requiring force privileges.
        /// - `pool_id`: The identifier of the pool to be destroyed.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `max_currencies`.
        /// - `Error::<T>::PoolNotLive`: If the pool is not in a live or
        ///   refunding state.
        /// - `Error::<T>::NoPermission`: If the caller is not the owner or
        ///   manager of the pool.
        /// </summary>
        force_start_destroy = 12,
        
        /// <summary>
        /// >> finish_destroy
        /// Finishes the destruction process for a pool. The pool will be
        /// removed from the storage and all leftover collateral and deposits
        /// will be refunded to the owner.
        /// 
        /// # Parameters
        /// - `origin`: The origin of the call.
        /// - `pool_id`: The identifier of the pool to be destroyed.
        /// - `currency_count`: The currency count in the pool, required for
        ///   weight calculation.
        /// 
        /// # Returns
        /// - `DispatchResultWithPostInfo`: The result of the dispatch with the
        ///   actual used weights.
        /// 
        /// # Errors
        /// - `Error::<T>::PoolUnknown`: If the pool does not exist.
        /// - `Error::<T>::CurrencyCount`: If the number of currencies exceeds
        ///   `currency_count`.
        /// - `Error::<T>::LivePool`: If the pool is not in a destroying state
        ///   or if there are any accounts left on any currency.
        /// </summary>
        finish_destroy = 13,
    }
    
    /// <summary>
    /// >> 375 - Variant[pallet_bonded_coins.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.pallet_bonded_coins.curves.EnumCurveInput, Kilt.NetApi.Generated.Model.staging_xcm.v4.location.Location, Kilt.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT26, Kilt.NetApi.Generated.Model.pallet_bonded_coins.types.BondedCurrenciesSettings>>(Call.create_pool);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Kilt.NetApi.Generated.Model.pallet_bonded_coins.types.PoolManagingTeam, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.reset_team);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseOpt<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32>>>(Call.reset_manager);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Kilt.NetApi.Generated.Model.pallet_bonded_coins.types.Locks>>(Call.set_lock);
				AddTypeDecoder<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32>(Call.unlock);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.mint_into);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.burn_into);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.start_refund);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.force_start_refund);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Kilt.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.refund_account);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.start_destroy);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.force_start_destroy);
				AddTypeDecoder<BaseTuple<Kilt.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.finish_destroy);
        }
    }
}
