//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Hydration.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> HSMStorage
    /// </summary>
    public sealed class HSMStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> HSMStorage Constructor
        /// </summary>
        public HSMStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("HSM", "Collaterals"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Hydration.NetApi.Generated.Model.pallet_hsm.types.CollateralInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("HSM", "HollarAmountReceived"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("HSM", "FlashMinter"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Hydration.NetApi.Generated.Model.primitive_types.H160)));
        }
        
        /// <summary>
        /// >> CollateralsParams
        ///  List of approved assets that Hollar can be purchased with
        /// 
        ///  This storage maps asset IDs to their collateral configuration information.
        ///  Only assets in this map can be used to mint or redeem Hollar through HSM.
        ///  Each collateral has specific parameters controlling its usage in the HSM mechanism.
        /// </summary>
        public static string CollateralsParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("HSM", "Collaterals", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CollateralsDefault
        /// Default value as hex string
        /// </summary>
        public static string CollateralsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Collaterals
        ///  List of approved assets that Hollar can be purchased with
        /// 
        ///  This storage maps asset IDs to their collateral configuration information.
        ///  Only assets in this map can be used to mint or redeem Hollar through HSM.
        ///  Each collateral has specific parameters controlling its usage in the HSM mechanism.
        /// </summary>
        public async Task<Hydration.NetApi.Generated.Model.pallet_hsm.types.CollateralInfo> Collaterals(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = HSMStorage.CollateralsParams(key);
            var result = await _client.GetStorageAsync<Hydration.NetApi.Generated.Model.pallet_hsm.types.CollateralInfo>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> HollarAmountReceivedParams
        ///  Amount of Hollar bought with an asset in a single block
        /// 
        ///  This storage tracks how much Hollar has been bought back by HSM for each collateral
        ///  asset within the current block. This is used to enforce rate limiting on Hollar redemptions.
        ///  Values are reset to zero at the end of each block in on_finalize.
        /// </summary>
        public static string HollarAmountReceivedParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("HSM", "HollarAmountReceived", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> HollarAmountReceivedDefault
        /// Default value as hex string
        /// </summary>
        public static string HollarAmountReceivedDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> HollarAmountReceived
        ///  Amount of Hollar bought with an asset in a single block
        /// 
        ///  This storage tracks how much Hollar has been bought back by HSM for each collateral
        ///  asset within the current block. This is used to enforce rate limiting on Hollar redemptions.
        ///  Values are reset to zero at the end of each block in on_finalize.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> HollarAmountReceived(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = HSMStorage.HollarAmountReceivedParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> FlashMinterParams
        ///  Address of the flash loan receiver.
        /// </summary>
        public static string FlashMinterParams()
        {
            return RequestGenerator.GetStorage("HSM", "FlashMinter", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> FlashMinterDefault
        /// Default value as hex string
        /// </summary>
        public static string FlashMinterDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> FlashMinter
        ///  Address of the flash loan receiver.
        /// </summary>
        public async Task<Hydration.NetApi.Generated.Model.primitive_types.H160> FlashMinter(string blockhash, CancellationToken token)
        {
            string parameters = HSMStorage.FlashMinterParams();
            var result = await _client.GetStorageAsync<Hydration.NetApi.Generated.Model.primitive_types.H160>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> HSMCalls
    /// </summary>
    public sealed class HSMCalls
    {
        
        /// <summary>
        /// >> add_collateral_asset
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method AddCollateralAsset(Substrate.NetApi.Model.Types.Primitive.U32 asset_id, Substrate.NetApi.Model.Types.Primitive.U32 pool_id, Hydration.NetApi.Generated.Model.sp_arithmetic.per_things.Permill purchase_fee, Hydration.NetApi.Generated.Model.sp_arithmetic.fixed_point.FixedU128 max_buy_price_coefficient, Hydration.NetApi.Generated.Model.sp_arithmetic.per_things.Permill buy_back_fee, Hydration.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill buyback_rate, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> max_in_holding)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            byteArray.AddRange(pool_id.Encode());
            byteArray.AddRange(purchase_fee.Encode());
            byteArray.AddRange(max_buy_price_coefficient.Encode());
            byteArray.AddRange(buy_back_fee.Encode());
            byteArray.AddRange(buyback_rate.Encode());
            byteArray.AddRange(max_in_holding.Encode());
            return new Method(82, "HSM", 0, "add_collateral_asset", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_collateral_asset
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RemoveCollateralAsset(Substrate.NetApi.Model.Types.Primitive.U32 asset_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            return new Method(82, "HSM", 1, "remove_collateral_asset", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_collateral_asset
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateCollateralAsset(Substrate.NetApi.Model.Types.Primitive.U32 asset_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_arithmetic.per_things.Permill> purchase_fee, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_arithmetic.fixed_point.FixedU128> max_buy_price_coefficient, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_arithmetic.per_things.Permill> buy_back_fee, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill> buyback_rate, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>> max_in_holding)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            byteArray.AddRange(purchase_fee.Encode());
            byteArray.AddRange(max_buy_price_coefficient.Encode());
            byteArray.AddRange(buy_back_fee.Encode());
            byteArray.AddRange(buyback_rate.Encode());
            byteArray.AddRange(max_in_holding.Encode());
            return new Method(82, "HSM", 2, "update_collateral_asset", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> sell
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Sell(Substrate.NetApi.Model.Types.Primitive.U32 asset_in, Substrate.NetApi.Model.Types.Primitive.U32 asset_out, Substrate.NetApi.Model.Types.Primitive.U128 amount_in, Substrate.NetApi.Model.Types.Primitive.U128 slippage_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_in.Encode());
            byteArray.AddRange(asset_out.Encode());
            byteArray.AddRange(amount_in.Encode());
            byteArray.AddRange(slippage_limit.Encode());
            return new Method(82, "HSM", 3, "sell", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> buy
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Buy(Substrate.NetApi.Model.Types.Primitive.U32 asset_in, Substrate.NetApi.Model.Types.Primitive.U32 asset_out, Substrate.NetApi.Model.Types.Primitive.U128 amount_out, Substrate.NetApi.Model.Types.Primitive.U128 slippage_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_in.Encode());
            byteArray.AddRange(asset_out.Encode());
            byteArray.AddRange(amount_out.Encode());
            byteArray.AddRange(slippage_limit.Encode());
            return new Method(82, "HSM", 4, "buy", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> execute_arbitrage
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ExecuteArbitrage(Substrate.NetApi.Model.Types.Primitive.U32 collateral_asset_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collateral_asset_id.Encode());
            return new Method(82, "HSM", 5, "execute_arbitrage", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_flash_minter
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetFlashMinter(Hydration.NetApi.Generated.Model.primitive_types.H160 flash_minter_addr)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(flash_minter_addr.Encode());
            return new Method(82, "HSM", 6, "set_flash_minter", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> HSMConstants
    /// </summary>
    public sealed class HSMConstants
    {
        
        /// <summary>
        /// >> HollarId
        ///  Asset ID of Hollar
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 HollarId()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xDE000000");
            return result;
        }
        
        /// <summary>
        /// >> PalletId
        ///  Pallet ID to determine HSM account
        /// </summary>
        public Hydration.NetApi.Generated.Model.frame_support.PalletId PalletId()
        {
            var result = new Hydration.NetApi.Generated.Model.frame_support.PalletId();
            result.Create("0x70792F68736D6F64");
            return result;
        }
        
        /// <summary>
        /// >> GasLimit
        ///  The gas limit for the execution of EVM calls
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U64 GasLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U64();
            result.Create("0x00093D0000000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> HSMErrors
    /// </summary>
    public enum HSMErrors
    {
        
        /// <summary>
        /// >> AssetNotApproved
        /// Asset is not approved as collateral
        /// 
        /// The operation attempted to use an asset that is not registered as an approved collateral.
        /// </summary>
        AssetNotApproved,
        
        /// <summary>
        /// >> AssetAlreadyApproved
        /// Asset is already approved as collateral
        /// 
        /// Attempted to add an asset that is already registered as a collateral.
        /// </summary>
        AssetAlreadyApproved,
        
        /// <summary>
        /// >> PoolAlreadyHasCollateral
        /// Another asset from the same pool is already approved
        /// 
        /// Only one asset from each StableSwap pool can be used as collateral.
        /// </summary>
        PoolAlreadyHasCollateral,
        
        /// <summary>
        /// >> InvalidAssetPair
        /// Invalid asset pair, must be Hollar and approved collateral
        /// 
        /// The asset pair for buy/sell operations must include Hollar as one side and an approved collateral as the other.
        /// </summary>
        InvalidAssetPair,
        
        /// <summary>
        /// >> MaxBuyPriceExceeded
        /// Max buy price exceeded
        /// 
        /// The calculated buy price exceeds the maximum allowed buy price for the collateral.
        /// </summary>
        MaxBuyPriceExceeded,
        
        /// <summary>
        /// >> MaxBuyBackExceeded
        /// Max buy back amount in single block exceeded
        /// 
        /// The amount of Hollar being sold to HSM exceeds the maximum allowed in a single block for this collateral.
        /// </summary>
        MaxBuyBackExceeded,
        
        /// <summary>
        /// >> MaxHoldingExceeded
        /// Max holding amount for collateral exceeded
        /// 
        /// The operation would cause the HSM to hold more of the collateral than the configured maximum.
        /// </summary>
        MaxHoldingExceeded,
        
        /// <summary>
        /// >> SlippageLimitExceeded
        /// Slippage limit exceeded
        /// 
        /// The calculated amount is worse than the provided slippage limit.
        /// </summary>
        SlippageLimitExceeded,
        
        /// <summary>
        /// >> InvalidEVMInteraction
        /// Invalid EVM contract interaction
        /// 
        /// The call to the EVM contract (GHO Hollar token) failed.
        /// </summary>
        InvalidEVMInteraction,
        
        /// <summary>
        /// >> DecimalRetrievalFailed
        /// Decimal retrieval failed
        /// 
        /// Failed to retrieve the decimal information for an asset.
        /// </summary>
        DecimalRetrievalFailed,
        
        /// <summary>
        /// >> NoArbitrageOpportunity
        /// No arbitrage opportunity
        /// 
        /// There is no profitable arbitrage opportunity for the specified collateral.
        /// </summary>
        NoArbitrageOpportunity,
        
        /// <summary>
        /// >> OffchainLockError
        /// Offchain lock error
        /// 
        /// Failed to acquire the lock for offchain workers, likely because another operation is in progress.
        /// </summary>
        OffchainLockError,
        
        /// <summary>
        /// >> AssetNotFound
        /// Asset not in the pool
        /// 
        /// The specified asset was not found in the pool.
        /// </summary>
        AssetNotFound,
        
        /// <summary>
        /// >> InvalidPoolState
        /// Provided pool state is invalid
        /// 
        /// The retrieved pool state has inconsistent or invalid data.
        /// </summary>
        InvalidPoolState,
        
        /// <summary>
        /// >> CollateralNotEmpty
        /// Collateral is not empty
        /// 
        /// Cannot remove a collateral asset that still has a non-zero balance in the HSM account.
        /// </summary>
        CollateralNotEmpty,
        
        /// <summary>
        /// >> AssetNotInPool
        /// Asset not in the pool
        /// 
        /// The collateral asset is not present in the specified pool.
        /// </summary>
        AssetNotInPool,
        
        /// <summary>
        /// >> HollarNotInPool
        /// Hollar is not in the pool
        /// 
        /// The Hollar asset is not present in the specified pool.
        /// </summary>
        HollarNotInPool,
        
        /// <summary>
        /// >> InsufficientCollateralBalance
        /// Insufficient collateral balance
        /// 
        /// The HSM does not have enough of the collateral asset to complete the operation.
        /// </summary>
        InsufficientCollateralBalance,
        
        /// <summary>
        /// >> HollarContractAddressNotFound
        /// GHO Contract address not found
        /// 
        /// The EVM address for the GHO (Hollar) token contract was not found.
        /// </summary>
        HollarContractAddressNotFound,
        
        /// <summary>
        /// >> MaxNumberOfCollateralsReached
        /// HSM contains maximum number of allowed collateral assets.
        /// </summary>
        MaxNumberOfCollateralsReached,
        
        /// <summary>
        /// >> FlashMinterNotSet
        /// Flash minter address not set
        /// </summary>
        FlashMinterNotSet,
        
        /// <summary>
        /// >> InvalidArbitrageData
        /// Provided arbitrage data is invalid
        /// </summary>
        InvalidArbitrageData,
    }
}
