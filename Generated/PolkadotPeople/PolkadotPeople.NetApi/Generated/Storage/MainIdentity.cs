//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace PolkadotPeople.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> IdentityStorage
    /// </summary>
    public sealed class IdentityStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> IdentityStorage Constructor
        /// </summary>
        public IdentityStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "IdentityOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.Registration)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "UsernameOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "SuperOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumData>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "SubsOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT24>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "Registrars"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT28)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "AuthorityOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT29), typeof(PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.AuthorityProperties)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "UsernameInfoOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6), typeof(PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.UsernameInformation)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "PendingUsernames"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumProvider>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "UnbindingUsernames"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6), typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
        }
        
        /// <summary>
        /// >> IdentityOfParams
        ///  Information that is pertinent to identify the entity behind an account. First item is the
        ///  registration, second is the account's primary username.
        /// 
        ///  TWOX-NOTE: OK ��� `AccountId` is a secure hash.
        /// </summary>
        public static string IdentityOfParams(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "IdentityOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> IdentityOfDefault
        /// Default value as hex string
        /// </summary>
        public static string IdentityOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> IdentityOf
        ///  Information that is pertinent to identify the entity behind an account. First item is the
        ///  registration, second is the account's primary username.
        /// 
        ///  TWOX-NOTE: OK ��� `AccountId` is a secure hash.
        /// </summary>
        public async Task<PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.Registration> IdentityOf(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.IdentityOfParams(key);
            var result = await _client.GetStorageAsync<PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.Registration>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UsernameOfParams
        ///  Identifies the primary username of an account.
        /// </summary>
        public static string UsernameOfParams(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "UsernameOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UsernameOfDefault
        /// Default value as hex string
        /// </summary>
        public static string UsernameOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UsernameOf
        ///  Identifies the primary username of an account.
        /// </summary>
        public async Task<PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6> UsernameOf(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.UsernameOfParams(key);
            var result = await _client.GetStorageAsync<PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SuperOfParams
        ///  The super-identity of an alternative "sub" identity together with its name, within that
        ///  context. If the account is not some other account's sub-identity, then just `None`.
        /// </summary>
        public static string SuperOfParams(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "SuperOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SuperOfDefault
        /// Default value as hex string
        /// </summary>
        public static string SuperOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SuperOf
        ///  The super-identity of an alternative "sub" identity together with its name, within that
        ///  context. If the account is not some other account's sub-identity, then just `None`.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumData>> SuperOf(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.SuperOfParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumData>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SubsOfParams
        ///  Alternative "sub" identities of this account.
        /// 
        ///  The first item is the deposit, the second is a vector of the accounts.
        /// 
        ///  TWOX-NOTE: OK ��� `AccountId` is a secure hash.
        /// </summary>
        public static string SubsOfParams(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "SubsOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SubsOfDefault
        /// Default value as hex string
        /// </summary>
        public static string SubsOfDefault()
        {
            return "0x0000000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> SubsOf
        ///  Alternative "sub" identities of this account.
        /// 
        ///  The first item is the deposit, the second is a vector of the accounts.
        /// 
        ///  TWOX-NOTE: OK ��� `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT24>> SubsOf(PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.SubsOfParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT24>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RegistrarsParams
        ///  The set of registrars. Not expected to get very big as can only be added through a
        ///  special origin (likely a council motion).
        /// 
        ///  The index into this can be cast to `RegistrarIndex` to get a valid value.
        /// </summary>
        public static string RegistrarsParams()
        {
            return RequestGenerator.GetStorage("Identity", "Registrars", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> RegistrarsDefault
        /// Default value as hex string
        /// </summary>
        public static string RegistrarsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Registrars
        ///  The set of registrars. Not expected to get very big as can only be added through a
        ///  special origin (likely a council motion).
        /// 
        ///  The index into this can be cast to `RegistrarIndex` to get a valid value.
        /// </summary>
        public async Task<PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT28> Registrars(string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.RegistrarsParams();
            var result = await _client.GetStorageAsync<PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT28>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AuthorityOfParams
        ///  A map of the accounts who are authorized to grant usernames.
        /// </summary>
        public static string AuthorityOfParams(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT29 key)
        {
            return RequestGenerator.GetStorage("Identity", "AuthorityOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AuthorityOfDefault
        /// Default value as hex string
        /// </summary>
        public static string AuthorityOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AuthorityOf
        ///  A map of the accounts who are authorized to grant usernames.
        /// </summary>
        public async Task<PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.AuthorityProperties> AuthorityOf(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT29 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.AuthorityOfParams(key);
            var result = await _client.GetStorageAsync<PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.AuthorityProperties>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UsernameInfoOfParams
        ///  Reverse lookup from `username` to the `AccountId` that has registered it and the provider of
        ///  the username. The `owner` value should be a key in the `UsernameOf` map, but it may not if
        ///  the user has cleared their username or it has been removed.
        /// 
        ///  Multiple usernames may map to the same `AccountId`, but `UsernameOf` will only map to one
        ///  primary username.
        /// </summary>
        public static string UsernameInfoOfParams(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 key)
        {
            return RequestGenerator.GetStorage("Identity", "UsernameInfoOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UsernameInfoOfDefault
        /// Default value as hex string
        /// </summary>
        public static string UsernameInfoOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UsernameInfoOf
        ///  Reverse lookup from `username` to the `AccountId` that has registered it and the provider of
        ///  the username. The `owner` value should be a key in the `UsernameOf` map, but it may not if
        ///  the user has cleared their username or it has been removed.
        /// 
        ///  Multiple usernames may map to the same `AccountId`, but `UsernameOf` will only map to one
        ///  primary username.
        /// </summary>
        public async Task<PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.UsernameInformation> UsernameInfoOf(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.UsernameInfoOfParams(key);
            var result = await _client.GetStorageAsync<PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.UsernameInformation>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PendingUsernamesParams
        ///  Usernames that an authority has granted, but that the account controller has not confirmed
        ///  that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
        ///  because they are a pure proxy, multisig, etc. In order to confirm it, they should call
        ///  [accept_username](`Call::accept_username`).
        /// 
        ///  First tuple item is the account and second is the acceptance deadline.
        /// </summary>
        public static string PendingUsernamesParams(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 key)
        {
            return RequestGenerator.GetStorage("Identity", "PendingUsernames", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PendingUsernamesDefault
        /// Default value as hex string
        /// </summary>
        public static string PendingUsernamesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> PendingUsernames
        ///  Usernames that an authority has granted, but that the account controller has not confirmed
        ///  that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
        ///  because they are a pure proxy, multisig, etc. In order to confirm it, they should call
        ///  [accept_username](`Call::accept_username`).
        /// 
        ///  First tuple item is the account and second is the acceptance deadline.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumProvider>> PendingUsernames(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.PendingUsernamesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumProvider>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UnbindingUsernamesParams
        ///  Usernames for which the authority that granted them has started the removal process by
        ///  unbinding them. Each unbinding username maps to its grace period expiry, which is the first
        ///  block in which the username could be deleted through a
        ///  [remove_username](`Call::remove_username`) call.
        /// </summary>
        public static string UnbindingUsernamesParams(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 key)
        {
            return RequestGenerator.GetStorage("Identity", "UnbindingUsernames", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UnbindingUsernamesDefault
        /// Default value as hex string
        /// </summary>
        public static string UnbindingUsernamesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UnbindingUsernames
        ///  Usernames for which the authority that granted them has started the removal process by
        ///  unbinding them. Each unbinding username maps to its grace period expiry, which is the first
        ///  block in which the username could be deleted through a
        ///  [remove_username](`Call::remove_username`) call.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> UnbindingUsernames(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.UnbindingUsernamesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> IdentityCalls
    /// </summary>
    public sealed class IdentityCalls
    {
        
        /// <summary>
        /// >> add_registrar
        /// Identity pallet declaration.
        /// </summary>
        public static Method AddRegistrar(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress account)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(account.Encode());
            return new Method(50, "Identity", 0, "add_registrar", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_identity
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetIdentity(PolkadotPeople.NetApi.Generated.Model.people_polkadot_runtime.people.IdentityInfo info)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(info.Encode());
            return new Method(50, "Identity", 1, "set_identity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_subs
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetSubs(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotPeople.NetApi.Generated.Model.sp_core.crypto.AccountId32, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumData>> subs)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(subs.Encode());
            return new Method(50, "Identity", 2, "set_subs", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_identity
        /// Identity pallet declaration.
        /// </summary>
        public static Method ClearIdentity()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(50, "Identity", 3, "clear_identity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> request_judgement
        /// Identity pallet declaration.
        /// </summary>
        public static Method RequestJudgement(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> reg_index, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> max_fee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(reg_index.Encode());
            byteArray.AddRange(max_fee.Encode());
            return new Method(50, "Identity", 4, "request_judgement", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_request
        /// Identity pallet declaration.
        /// </summary>
        public static Method CancelRequest(Substrate.NetApi.Model.Types.Primitive.U32 reg_index)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(reg_index.Encode());
            return new Method(50, "Identity", 5, "cancel_request", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_fee
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetFee(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> index, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> fee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(index.Encode());
            byteArray.AddRange(fee.Encode());
            return new Method(50, "Identity", 6, "set_fee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_account_id
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetAccountId(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> index, PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(index.Encode());
            byteArray.AddRange(@new.Encode());
            return new Method(50, "Identity", 7, "set_account_id", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_fields
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetFields(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> index, Substrate.NetApi.Model.Types.Primitive.U64 fields)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(index.Encode());
            byteArray.AddRange(fields.Encode());
            return new Method(50, "Identity", 8, "set_fields", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> provide_judgement
        /// Identity pallet declaration.
        /// </summary>
        public static Method ProvideJudgement(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> reg_index, PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress target, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumJudgement judgement, PolkadotPeople.NetApi.Generated.Model.primitive_types.H256 identity)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(reg_index.Encode());
            byteArray.AddRange(target.Encode());
            byteArray.AddRange(judgement.Encode());
            byteArray.AddRange(identity.Encode());
            return new Method(50, "Identity", 9, "provide_judgement", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kill_identity
        /// Identity pallet declaration.
        /// </summary>
        public static Method KillIdentity(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress target)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(target.Encode());
            return new Method(50, "Identity", 10, "kill_identity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method AddSub(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress sub, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumData data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(sub.Encode());
            byteArray.AddRange(data.Encode());
            return new Method(50, "Identity", 11, "add_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> rename_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method RenameSub(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress sub, PolkadotPeople.NetApi.Generated.Model.pallet_identity.types.EnumData data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(sub.Encode());
            byteArray.AddRange(data.Encode());
            return new Method(50, "Identity", 12, "rename_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveSub(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress sub)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(sub.Encode());
            return new Method(50, "Identity", 13, "remove_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> quit_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method QuitSub()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(50, "Identity", 14, "quit_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_username_authority
        /// Identity pallet declaration.
        /// </summary>
        public static Method AddUsernameAuthority(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress authority, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> suffix, Substrate.NetApi.Model.Types.Primitive.U32 allocation)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(authority.Encode());
            byteArray.AddRange(suffix.Encode());
            byteArray.AddRange(allocation.Encode());
            return new Method(50, "Identity", 15, "add_username_authority", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_username_authority
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveUsernameAuthority(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> suffix, PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress authority)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(suffix.Encode());
            byteArray.AddRange(authority.Encode());
            return new Method(50, "Identity", 16, "remove_username_authority", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_username_for
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetUsernameFor(PolkadotPeople.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress who, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> username, Substrate.NetApi.Model.Types.Base.BaseOpt<PolkadotPeople.NetApi.Generated.Model.sp_runtime.EnumMultiSignature> signature, Substrate.NetApi.Model.Types.Primitive.Bool use_allocation)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(who.Encode());
            byteArray.AddRange(username.Encode());
            byteArray.AddRange(signature.Encode());
            byteArray.AddRange(use_allocation.Encode());
            return new Method(50, "Identity", 17, "set_username_for", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> accept_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method AcceptUsername(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(50, "Identity", 18, "accept_username", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_expired_approval
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveExpiredApproval(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(50, "Identity", 19, "remove_expired_approval", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_primary_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetPrimaryUsername(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(50, "Identity", 20, "set_primary_username", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unbind_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method UnbindUsername(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(50, "Identity", 21, "unbind_username", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveUsername(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(50, "Identity", 22, "remove_username", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kill_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method KillUsername(PolkadotPeople.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(50, "Identity", 23, "kill_username", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> IdentityConstants
    /// </summary>
    public sealed class IdentityConstants
    {
        
        /// <summary>
        /// >> BasicDeposit
        ///  The amount held on deposit for a registered identity.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 BasicDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0xA0844F77000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> ByteDeposit
        ///  The amount held on deposit per encoded byte for a registered identity.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 ByteDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0xA0860100000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> UsernameDeposit
        ///  The amount held on deposit per registered username. This value should change only in
        ///  runtime upgrades with proper migration of existing deposits.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 UsernameDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00D43000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> SubAccountDeposit
        ///  The amount held on deposit for a registered subaccount. This should account for the fact
        ///  that one storage item's value will increase by the size of an account ID, and there will
        ///  be another trie item whose value is the size of an account ID plus 32 bytes.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 SubAccountDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x20738677000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxSubAccounts
        ///  The maximum number of sub-accounts allowed per identified account.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxSubAccounts()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x64000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxRegistrars
        ///  Maximum number of registrars allowed in the system. Needed to bound the complexity
        ///  of, e.g., updating judgements.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxRegistrars()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x14000000");
            return result;
        }
        
        /// <summary>
        /// >> PendingUsernameExpiration
        ///  The number of blocks within which a username grant must be accepted.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 PendingUsernameExpiration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xE0C40000");
            return result;
        }
        
        /// <summary>
        /// >> UsernameGracePeriod
        ///  The number of blocks that must pass to enable the permanent deletion of a username by
        ///  its respective authority.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 UsernameGracePeriod()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x60540000");
            return result;
        }
        
        /// <summary>
        /// >> MaxSuffixLength
        ///  The maximum length of a suffix.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxSuffixLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x07000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxUsernameLength
        ///  The maximum length of a username, including its suffix and any system-added delimiters.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxUsernameLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x20000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> IdentityErrors
    /// </summary>
    public enum IdentityErrors
    {
        
        /// <summary>
        /// >> TooManySubAccounts
        /// Too many subs-accounts.
        /// </summary>
        TooManySubAccounts,
        
        /// <summary>
        /// >> NotFound
        /// Account isn't found.
        /// </summary>
        NotFound,
        
        /// <summary>
        /// >> NotNamed
        /// Account isn't named.
        /// </summary>
        NotNamed,
        
        /// <summary>
        /// >> EmptyIndex
        /// Empty index.
        /// </summary>
        EmptyIndex,
        
        /// <summary>
        /// >> FeeChanged
        /// Fee is changed.
        /// </summary>
        FeeChanged,
        
        /// <summary>
        /// >> NoIdentity
        /// No identity found.
        /// </summary>
        NoIdentity,
        
        /// <summary>
        /// >> StickyJudgement
        /// Sticky judgement.
        /// </summary>
        StickyJudgement,
        
        /// <summary>
        /// >> JudgementGiven
        /// Judgement given.
        /// </summary>
        JudgementGiven,
        
        /// <summary>
        /// >> InvalidJudgement
        /// Invalid judgement.
        /// </summary>
        InvalidJudgement,
        
        /// <summary>
        /// >> InvalidIndex
        /// The index is invalid.
        /// </summary>
        InvalidIndex,
        
        /// <summary>
        /// >> InvalidTarget
        /// The target is invalid.
        /// </summary>
        InvalidTarget,
        
        /// <summary>
        /// >> TooManyRegistrars
        /// Maximum amount of registrars reached. Cannot add any more.
        /// </summary>
        TooManyRegistrars,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// Account ID is already named.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> NotSub
        /// Sender is not a sub-account.
        /// </summary>
        NotSub,
        
        /// <summary>
        /// >> NotOwned
        /// Sub-account isn't owned by sender.
        /// </summary>
        NotOwned,
        
        /// <summary>
        /// >> JudgementForDifferentIdentity
        /// The provided judgement was for a different identity.
        /// </summary>
        JudgementForDifferentIdentity,
        
        /// <summary>
        /// >> JudgementPaymentFailed
        /// Error that occurs when there is an issue paying for judgement.
        /// </summary>
        JudgementPaymentFailed,
        
        /// <summary>
        /// >> InvalidSuffix
        /// The provided suffix is too long.
        /// </summary>
        InvalidSuffix,
        
        /// <summary>
        /// >> NotUsernameAuthority
        /// The sender does not have permission to issue a username.
        /// </summary>
        NotUsernameAuthority,
        
        /// <summary>
        /// >> NoAllocation
        /// The authority cannot allocate any more usernames.
        /// </summary>
        NoAllocation,
        
        /// <summary>
        /// >> InvalidSignature
        /// The signature on a username was not valid.
        /// </summary>
        InvalidSignature,
        
        /// <summary>
        /// >> RequiresSignature
        /// Setting this username requires a signature, but none was provided.
        /// </summary>
        RequiresSignature,
        
        /// <summary>
        /// >> InvalidUsername
        /// The username does not meet the requirements.
        /// </summary>
        InvalidUsername,
        
        /// <summary>
        /// >> UsernameTaken
        /// The username is already taken.
        /// </summary>
        UsernameTaken,
        
        /// <summary>
        /// >> NoUsername
        /// The requested username does not exist.
        /// </summary>
        NoUsername,
        
        /// <summary>
        /// >> NotExpired
        /// The username cannot be forcefully removed because it can still be accepted.
        /// </summary>
        NotExpired,
        
        /// <summary>
        /// >> TooEarly
        /// The username cannot be removed because it's still in the grace period.
        /// </summary>
        TooEarly,
        
        /// <summary>
        /// >> NotUnbinding
        /// The username cannot be removed because it is not unbinding.
        /// </summary>
        NotUnbinding,
        
        /// <summary>
        /// >> AlreadyUnbinding
        /// The username cannot be unbound because it is already unbinding.
        /// </summary>
        AlreadyUnbinding,
        
        /// <summary>
        /// >> InsufficientPrivileges
        /// The action cannot be performed because of insufficient privileges (e.g. authority
        /// trying to unbind a username provided by the system).
        /// </summary>
        InsufficientPrivileges,
    }
}
